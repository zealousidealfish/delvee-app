<!-- delvee/lobby.html (FULL FILE REPLACEMENT) -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Lobby — Delvee</title>
  <meta name="theme-color" content="#0F1114" id="meta-theme-color" />

  <link rel="stylesheet" href="./styles.css" />

  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-functions-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>

  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyCECKG-00tijJrt5qvRy3L27ZzE7bocNrU",
      authDomain: "setfeed-fcd7a.firebaseapp.com",
      projectId: "setfeed-fcd7a",
      storageBucket: "setfeed-fcd7a.firebasestorage.app",
      messagingSenderId: "553573263069",
      appId: "1:553573263069:web:e5c9884101ca38eaee1d34"
    };

    if (!firebase.apps || firebase.apps.length === 0) firebase.initializeApp(firebaseConfig);

    const auth = firebase.auth();
    const functions = firebase.app().functions("europe-west2");
    const db = firebase.firestore();
  </script>

  <!-- Theme (Lobby defaults to DARK if nothing set; does not overwrite storage) -->
  <script>
    (function(){
      const THEME_KEY = "sf_theme_mode";
      const root = document.documentElement;

      function readStoredRaw(){
        try { return localStorage.getItem(THEME_KEY); } catch (_) { return null; }
      }

      function applyTheme(){
        const storedRaw = readStoredRaw();
        const stored = storedRaw || "system";

        if (!storedRaw) root.setAttribute("data-theme", "dark");
        else if (stored === "light" || stored === "dark") root.setAttribute("data-theme", stored);
        else root.removeAttribute("data-theme");

        const effective =
          root.getAttribute("data-theme") ||
          (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light");

        const meta = document.getElementById("meta-theme-color");
        if (meta) meta.content = (effective === "dark") ? "#0F1114" : "#FFFBFE";
      }

      function setToggleLabel(){
        const btn = document.getElementById("themeToggle");
        if (!btn) return;

        const storedRaw = readStoredRaw();
        const stored = storedRaw || "system";

        const effective =
          (!storedRaw) ? "dark" :
          (stored === "light" || stored === "dark") ? stored :
          (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light");

        btn.textContent = effective === "dark" ? "Light" : "Dark";
        btn.setAttribute("aria-label", effective === "dark" ? "Switch to light theme" : "Switch to dark theme");
      }

      function wireToggle(){
        const btn = document.getElementById("themeToggle");
        if (!btn) return;

        btn.addEventListener("click", () => {
          const storedRaw = readStoredRaw();
          const stored = storedRaw || "system";

          const effective =
            (!storedRaw) ? "dark" :
            (stored === "light" || stored === "dark") ? stored :
            (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light");

          const next = (effective === "dark") ? "light" : "dark";
          try { localStorage.setItem(THEME_KEY, next); } catch (_) {}
          applyTheme();
          setToggleLabel();
        });

        if (window.matchMedia) {
          const mq = window.matchMedia("(prefers-color-scheme: dark)");
          try {
            mq.addEventListener("change", () => { applyTheme(); setToggleLabel(); });
          } catch (_) {}
        }
      }

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", () => {
          applyTheme();
          setToggleLabel();
          wireToggle();
        }, { once: true });
      } else {
        applyTheme();
        setToggleLabel();
        wireToggle();
      }

      window.addEventListener("storage", (e) => {
        if (e && e.key === THEME_KEY) { applyTheme(); setToggleLabel(); }
      });
    })();
  </script>
</head>

<body class="dv-bg">
  <header class="dv-top">
    <div class="dv-top-inner">
      <div class="dv-brand">
        <a class="dv-mark" href="./index.html" aria-label="Delvee home"></a>
        <div>
          <div class="dv-title">Delvee</div>
          <div class="dv-sub" id="sessionLabel">Lobby</div>
        </div>
      </div>

      <div class="dv-top-actions">
        <button class="dv-theme-toggle" id="themeToggle" type="button">Theme</button>
        <button class="dv-chip" id="btn-copy" type="button">Copy code</button>
        <button class="dv-chip" id="btn-home" type="button">Home</button>
        <button class="dv-chip" id="btn-leave" type="button">Leave</button>
      </div>
    </div>
  </header>

  <main class="dv-wrap dv-wrap-wide">
    <section class="dv-card dv-card-wide">

      <div class="dv-status dv-status-tight" id="status">
        <span class="dv-dot" id="statusDot"></span>
        <div>
          <div class="dv-status-title" id="statusTitle">Connecting…</div>
          <div class="dv-status-line" id="statusLine">Preparing realtime lobby.</div>
        </div>
        <div class="dv-right" id="countdown"></div>
      </div>

      <div class="dv-layout">
        <!-- Left: participants -->
        <aside class="dv-side">
          <div class="dv-panel">
            <div class="dv-panel-head">
              <h2 class="dv-h2">Participants</h2>
              <div class="dv-pill" id="statePill">—</div>
            </div>

            <div class="dv-list" id="participants"></div>

            <div class="dv-hr"></div>

            <div class="dv-actions dv-actions-compact">
              <button class="dv-btn" id="btn-ready" type="button">Ready</button>

              <div class="dv-host hidden" id="hostControls">
                <select id="duration" class="dv-select" aria-label="Duration">
                  <option value="4">4 min</option>
                  <option value="5">5 min</option>
                </select>
                <button class="dv-btn dv-btn-primary" id="btn-start" type="button">Start</button>
              </div>
            </div>

            <p class="dv-help" id="hint">
              This is the threshold. Ready means you’re in. The host begins the window.
            </p>

            <!-- Setfeed summary delivery -->
            <div class="dv-summary" id="setfeedPanel">
              <h3 class="dv-summary-title">Setfeed summary delivery</h3>
              <input class="dv-input" id="setfeedCode" placeholder="Paste your Setfeed receive code (SF-… or SFS-…)" />
              <div class="dv-minirow">
                <button class="dv-btn" id="btn-toggle-autosend" type="button">Auto-send: Off</button>
                <button class="dv-btn dv-btn-primary" id="btn-send-summary" type="button" disabled>Send summary</button>
              </div>
              <div class="dv-muted2" id="setfeedStatus">Tip: each participant uses their own receive code (summary encrypts locally).</div>
            </div>
          </div>
        </aside>

        <!-- Center: live feed + composer -->
        <section class="dv-main">
          <div class="dv-panel">
            <div class="dv-panel-head">
              <h2 class="dv-h2">Live preview</h2>
              <div class="dv-muted" id="feedMeta">—</div>
            </div>

            <div class="dv-feed" id="feed"></div>

            <div class="dv-composer" id="composer">
              <div class="dv-compose-row">
                <textarea id="pulseText" maxlength="100" placeholder="Write a pulse (≤100 chars)"></textarea>
                <button class="dv-btn dv-btn-primary" id="btn-pulse" type="button">Pulse</button>
              </div>

              <div class="dv-compose-row dv-compose-row2">
                <input class="dv-file dv-file-input" id="pulseImage" type="file" accept="image/*" />

                <button class="dv-file-chip" id="btn-choose-image" type="button" aria-label="Choose image">
                  <span class="dv-file-dot" aria-hidden="true"></span>
                  <span id="dv-file-chip-label">Choose image</span>
                </button>

                <button class="dv-btn" id="btn-image" type="button">Pulse image</button>
              </div>

              <div class="dv-help dv-help-tight" id="composerHelp">
                Fast, short, deliberate. Throttling is enforced.
              </div>
            </div>

            <!-- Summary view (DONE) -->
            <div class="dv-summary hidden" id="summaryPanel">
              <h3 class="dv-summary-title">Session summary</h3>
              <pre id="summaryText">—</pre>
              <div class="dv-minirow">
                <button class="dv-btn dv-btn-primary" id="btn-send-summary-2" type="button" disabled>Send to Setfeed</button>
              </div>
              <div class="dv-muted2" id="summaryMeta">Generated on DONE.</div>
            </div>

          </div>
        </section>

        <!-- Right: chat (cooldown/done only) -->
        <aside class="dv-side">
          <div class="dv-panel">
            <div class="dv-panel-head">
              <h2 class="dv-h2">Chat</h2>
              <div class="dv-muted" id="chatMeta">Opens in cooldown</div>
            </div>

            <div class="dv-chat" id="chat"></div>

            <div class="dv-chatbox">
              <input id="chatText" maxlength="300" placeholder="Ask who sent what…" />
              <button class="dv-btn" id="btn-chat" type="button">Send</button>
            </div>

            <div class="dv-help dv-help-tight">
              Chat is for attribution guesses — not discussion.
            </div>
          </div>
        </aside>
      </div>

    </section>
  </main>

  <script>
    // -------------------------
    // Utilities
    // -------------------------
    const qs = new URLSearchParams(window.location.search);
    const sessionId = (qs.get("session") || "").trim().toUpperCase();

    const ALIAS_KEY = "dv_alias";
    const LAST_SESSION_KEY = "dv_last_session";

    const SETFEED_CODE_KEY = "dv_setfeed_receive_code";
    const SETFEED_AUTOSEND_KEY = "dv_setfeed_autosend";

    const SENT_FLAG_KEY = `dv_setfeed_summary_sent_${sessionId}`;

    const myAlias = (() => {
      try { return (localStorage.getItem(ALIAS_KEY) || "").trim(); } catch (_) { return ""; }
    })();

    function setLastSession(sid) {
      try { localStorage.setItem(LAST_SESSION_KEY, String(sid || "").trim().toUpperCase()); } catch (_) {}
    }

    function setStatus(kind, title, line) {
      const dot = document.getElementById("statusDot");
      const t = document.getElementById("statusTitle");
      const l = document.getElementById("statusLine");
      dot.className = "dv-dot";
      if (kind === "good") dot.classList.add("good");
      if (kind === "warn") dot.classList.add("warn");
      t.textContent = title;
      l.textContent = line;
    }

    function fmtMs(ms) {
      const s = Math.max(0, Math.floor(ms / 1000));
      const mm = String(Math.floor(s / 60)).padStart(2, "0");
      const ss = String(s % 60).padStart(2, "0");
      return `${mm}:${ss}`;
    }

    function randomId(prefix) {
      return `${prefix}_${Date.now()}_${Math.random().toString(16).slice(2)}`;
    }

    function escapeHtml(s) {
      return String(s || "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;");
    }

    function setHidden(el, hidden) {
      if (!el) return;
      el.classList.toggle("hidden", !!hidden);
    }

    if (!sessionId) {
      setStatus("warn", "Missing session", "Open a lobby from Delvee home.");
      setTimeout(() => window.location.href = "./index.html", 700);
    } else {
      setLastSession(sessionId);
    }

    document.getElementById("sessionLabel").textContent = sessionId ? `Session ${sessionId}` : "Lobby";

    // -------------------------
    // Elements
    // -------------------------
    const btnCopy = document.getElementById("btn-copy");
    const btnLeave = document.getElementById("btn-leave");
    const btnHome = document.getElementById("btn-home");

    const participantsEl = document.getElementById("participants");
    const statePill = document.getElementById("statePill");
    const hint = document.getElementById("hint");

    const btnReady = document.getElementById("btn-ready");
    const hostControls = document.getElementById("hostControls");
    const btnStart = document.getElementById("btn-start");
    const durationSel = document.getElementById("duration");

    const countdownEl = document.getElementById("countdown");

    const feed = document.getElementById("feed");
    const feedMeta = document.getElementById("feedMeta");

    const composer = document.getElementById("composer");
    const pulseText = document.getElementById("pulseText");
    const btnPulse = document.getElementById("btn-pulse");
    const pulseImage = document.getElementById("pulseImage");
    const btnImage = document.getElementById("btn-image");
    const composerHelp = document.getElementById("composerHelp");

    const btnChooseImage = document.getElementById("btn-choose-image");
    const chipLabel = document.getElementById("dv-file-chip-label");

    const chat = document.getElementById("chat");
    const chatText = document.getElementById("chatText");
    const btnChat = document.getElementById("btn-chat");
    const chatMeta = document.getElementById("chatMeta");

    const summaryPanel = document.getElementById("summaryPanel");
    const summaryTextEl = document.getElementById("summaryText");
    const summaryMeta = document.getElementById("summaryMeta");
    const btnSendSummary = document.getElementById("btn-send-summary");
    const btnSendSummary2 = document.getElementById("btn-send-summary-2");

    const setfeedCodeInput = document.getElementById("setfeedCode");
    const btnToggleAutosend = document.getElementById("btn-toggle-autosend");
    const setfeedStatus = document.getElementById("setfeedStatus");

    // -------------------------
    // Firestore refs
    // -------------------------
    const sref = db.collection("delvee_sessions").doc(sessionId);
    const pref = sref.collection("participants");
    const pulsesRef = sref.collection("pulses");
    const chatRef = sref.collection("chat");

    // -------------------------
    // Local state
    // -------------------------
    let unsub = [];
    let session = null;
    let me = null;
    let isHost = false;
    let state = "—";

    let pendingTextPulse = null;
    let pendingImagePulse = null;

    const downloadUrlCache = new Map(); // storagePath -> {url, exp}

    // -------------------------
    // Chip file picker wiring
    // -------------------------
    function renderChosenFileName() {
      const f = (pulseImage && pulseImage.files && pulseImage.files[0]) ? pulseImage.files[0] : null;
      if (!chipLabel) return;

      if (!f) {
        chipLabel.textContent = "Choose image";
        return;
      }

      chipLabel.innerHTML = "";
      const name = document.createElement("span");
      name.className = "dv-file-name";
      name.textContent = f.name;

      const clear = document.createElement("button");
      clear.className = "dv-file-clear";
      clear.type = "button";
      clear.textContent = "×";
      clear.setAttribute("aria-label", "Clear selected image");
      clear.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        pulseImage.value = "";
        renderChosenFileName();
      });

      chipLabel.appendChild(name);
      chipLabel.appendChild(clear);
    }

    if (btnChooseImage && pulseImage) {
      btnChooseImage.addEventListener("click", () => pulseImage.click());
      pulseImage.addEventListener("change", renderChosenFileName);
      renderChosenFileName();
    }

    // -------------------------
    // Setfeed crypto helpers (client-side encrypt)
    // -------------------------
    function normalizeCodeAndroid(raw) { return String(raw || "").trim().toUpperCase().replace(/[\s-]/g, ""); }

    function bytesToB64(bytes) {
      let bin = "";
      const arr = (bytes instanceof Uint8Array) ? bytes : new Uint8Array(bytes);
      for (let i = 0; i < arr.length; i++) bin += String.fromCharCode(arr[i]);
      return btoa(bin);
    }

    async function sha256Hex(str) {
      const data = new TextEncoder().encode(str);
      const hash = await crypto.subtle.digest("SHA-256", data);
      return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, "0")).join("");
    }

    async function deriveAesKeyFromPassphrase(passphrase, saltBytes) {
      const passBytes = new TextEncoder().encode(passphrase);
      const baseKey = await crypto.subtle.importKey("raw", passBytes, { name: "PBKDF2" }, false, ["deriveKey"]);
      return await crypto.subtle.deriveKey(
        { name: "PBKDF2", salt: saltBytes, iterations: 100000, hash: "SHA-256" },
        baseKey,
        { name: "AES-GCM", length: 256 },
        false,
        ["encrypt"]
      );
    }

    async function encryptForCode(rawCode, plaintext) {
      const passphrase = normalizeCodeAndroid(rawCode);
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveAesKeyFromPassphrase(passphrase, salt);

      const ptBytes = new TextEncoder().encode(String(plaintext || ""));
      const ct = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, ptBytes);

      return {
        ciphertextB64: bytesToB64(new Uint8Array(ct)),
        ivB64: bytesToB64(iv),
        saltB64: bytesToB64(salt),
      };
    }

    function tzName() {
      try { return Intl.DateTimeFormat().resolvedOptions().timeZone || "UTC"; } catch (_) { return "UTC"; }
    }

    function getAutosend() {
      try { return localStorage.getItem(SETFEED_AUTOSEND_KEY) === "true"; } catch (_) { return false; }
    }
    function setAutosend(v) {
      try { localStorage.setItem(SETFEED_AUTOSEND_KEY, v ? "true" : "false"); } catch (_) {}
    }

    function getStoredSetfeedCode() {
      try { return (localStorage.getItem(SETFEED_CODE_KEY) || "").trim(); } catch (_) { return ""; }
    }
    function setStoredSetfeedCode(v) {
      try { localStorage.setItem(SETFEED_CODE_KEY, String(v || "").trim()); } catch (_) {}
    }

    function hasSentForThisSession() {
      try { return localStorage.getItem(SENT_FLAG_KEY) === "true"; } catch (_) { return false; }
    }
    function markSentForThisSession() {
      try { localStorage.setItem(SENT_FLAG_KEY, "true"); } catch (_) {}
    }

    function refreshSetfeedUI() {
      const auto = getAutosend();
      btnToggleAutosend.textContent = `Auto-send: ${auto ? "On" : "Off"}`;

      const code = (setfeedCodeInput.value || "").trim();
      const canSend = !!code && !!session && state === "DONE" && !!(session.summaryText);
      btnSendSummary.disabled = !canSend;
      btnSendSummary2.disabled = !canSend;

      if (hasSentForThisSession()) {
        setfeedStatus.textContent = "Summary sent to your Setfeed inbox for this session.";
      } else if (!code) {
        setfeedStatus.textContent = "Paste your Setfeed receive code. Summary encrypts locally and sends to your inbox.";
      } else if (state !== "DONE") {
        setfeedStatus.textContent = "Summary sends when the session is DONE (or you can send once it appears).";
      } else if (session && session.summaryText) {
        setfeedStatus.textContent = auto ? "Auto-send is ON: will send once per session." : "Ready to send.";
      } else {
        setfeedStatus.textContent = "Waiting for summary generation…";
      }
    }

    async function sendSummaryToSetfeed() {
      if (!auth.currentUser) return;

      const codeRaw = (setfeedCodeInput.value || "").trim();
      if (!codeRaw) {
        setStatus("warn", "Missing code", "Paste your Setfeed receive code first.");
        return;
      }
      if (!session || !session.summaryText) {
        setStatus("warn", "No summary", "Summary not ready yet.");
        return;
      }
      if (hasSentForThisSession()) {
        setStatus("good", "Already sent", "This session’s summary has already been sent from this device.");
        refreshSetfeedUI();
        return;
      }

      try {
        btnSendSummary.disabled = true;
        btnSendSummary2.disabled = true;
        setfeedStatus.textContent = "Encrypting + sending…";

        const normalized = normalizeCodeAndroid(codeRaw);
        const codeHash = await sha256Hex(normalized);

        const enc = await encryptForCode(codeRaw, session.summaryText);

        const deliverAtLocalIso = new Date().toISOString();
        const call = functions.httpsCallable("sendSignedCiphertext");

        await call({
          codeHash,
          ciphertext: enc.ciphertextB64,
          iv: enc.ivB64,
          salt: enc.saltB64,
          deliverAtLocalIso,
          userTimezone: tzName(),
          clientRequestId: randomId("sum"),
          attachments: [],
        });

        markSentForThisSession();
        setfeedStatus.textContent = "Sent — check your Setfeed Inbox.";
        setStatus("good", "Sent", "Summary delivered to your Setfeed Inbox.");
      } catch (e) {
        console.error(e);
        setfeedStatus.textContent = "Couldn’t send. Check you’re signed in and the code is valid.";
        setStatus("warn", "Send failed", (e && e.message) ? e.message : "Try again.");
      } finally {
        refreshSetfeedUI();
      }
    }

    // -------------------------
    // Actions
    // -------------------------
    btnHome.addEventListener("click", () => { window.location.href = "./index.html"; });

    btnCopy.addEventListener("click", async () => {
      try {
        await navigator.clipboard.writeText(sessionId);
        setStatus("good", "Copied", "Session code copied.");
      } catch (_) {
        setStatus("warn", "Copy failed", "Copy manually from the header.");
      }
    });

    btnLeave.addEventListener("click", async () => {
      try {
        const leave = functions.httpsCallable("delveeLeaveSession");
        await leave({ sessionId });
      } catch (_) {}
      window.location.href = "./index.html";
    });

    btnReady.addEventListener("click", async () => {
      if (!auth.currentUser) return;

      const next = !(me && me.ready);
      try {
        btnReady.disabled = true;
        const call = functions.httpsCallable("delveeSetReady");
        await call({ sessionId, ready: next });
      } catch (e) {
        console.error(e);
        setStatus("warn", "Couldn’t update", (e && e.message) ? e.message : "Try again.");
      } finally {
        btnReady.disabled = false;
      }
    });

    btnStart.addEventListener("click", async () => {
      if (!isHost) return;
      try {
        btnStart.disabled = true;
        const call = functions.httpsCallable("delveeStartSession");
        await call({ sessionId, durationMinutes: Number(durationSel.value) });
      } catch (e) {
        console.error(e);
        setStatus("warn", "Couldn’t start", (e && e.message) ? e.message : "Try again.");
      } finally {
        btnStart.disabled = false;
      }
    });

    btnPulse.addEventListener("click", async () => {
      const text = pulseText.value.trim();
      if (!text) return;

      if (state !== "RUNNING") {
        setStatus("warn", "Not running", "Wait for the host to start.");
        return;
      }

      try {
        btnPulse.disabled = true;
        composerHelp.textContent = "Sending pulse…";

        if (!pendingTextPulse) pendingTextPulse = randomId("p");
        const call = functions.httpsCallable("delveePulseText");
        await call({ sessionId, clientPulseId: pendingTextPulse, text });

        pendingTextPulse = null;
        pulseText.value = "";
        composerHelp.textContent = "Pulsed.";
      } catch (e) {
        console.error(e);
        composerHelp.textContent = "Couldn’t pulse. Try again.";
        setStatus("warn", "Pulse failed", (e && e.message) ? e.message : "Try again.");
      } finally {
        btnPulse.disabled = false;
      }
    });

    btnImage.addEventListener("click", async () => {
      const file = pulseImage.files && pulseImage.files[0];
      if (!file) return;

      if (state !== "RUNNING") {
        setStatus("warn", "Not running", "Wait for the host to start.");
        return;
      }

      if (!file.type.startsWith("image/")) {
        setStatus("warn", "Not an image", "Choose an image file.");
        return;
      }

      try {
        btnImage.disabled = true;
        composerHelp.textContent = "Uploading image…";

        if (!pendingImagePulse) pendingImagePulse = randomId("img");

        const attachmentId = randomId("a");
        const create = functions.httpsCallable("delveeCreateImageUpload");
        const res = await create({
          sessionId,
          attachmentId,
          sizeBytes: file.size,
          contentType: file.type
        });

        const { uploadUrl, storagePath } = res.data || {};
        if (!uploadUrl || !storagePath) throw new Error("Missing uploadUrl/storagePath");

        const bytes = await file.arrayBuffer();
        await fetch(uploadUrl, {
          method: "PUT",
          headers: { "Content-Type": "application/octet-stream" },
          body: bytes
        });

        const commit = functions.httpsCallable("delveePulseImageCommit");
        await commit({
          sessionId,
          clientPulseId: pendingImagePulse,
          attachment: {
            storagePath,
            contentType: file.type,
            sizeBytes: file.size
          }
        });

        pendingImagePulse = null;
        pulseImage.value = "";
        renderChosenFileName();
        composerHelp.textContent = "Image pulsed.";
      } catch (e) {
        console.error(e);
        composerHelp.textContent = "Couldn’t pulse image. Try again.";
        setStatus("warn", "Image failed", (e && e.message) ? e.message : "Try again.");
      } finally {
        btnImage.disabled = false;
      }
    });

    btnChat.addEventListener("click", async () => {
      const text = chatText.value.trim();
      if (!text) return;

      if (state !== "COOLDOWN" && state !== "DONE") {
        setStatus("warn", "Chat closed", "Chat opens during cooldown.");
        return;
      }

      try {
        btnChat.disabled = true;
        const call = functions.httpsCallable("delveeChatSend");
        await call({ sessionId, text });
        chatText.value = "";
      } catch (e) {
        console.error(e);
        setStatus("warn", "Chat failed", (e && e.message) ? e.message : "Try again.");
      } finally {
        btnChat.disabled = false;
      }
    });

    setfeedCodeInput.value = getStoredSetfeedCode();
    setfeedCodeInput.addEventListener("input", () => {
      setStoredSetfeedCode(setfeedCodeInput.value);
      refreshSetfeedUI();
    });

    btnToggleAutosend.addEventListener("click", () => {
      setAutosend(!getAutosend());
      refreshSetfeedUI();
    });

    btnSendSummary.addEventListener("click", sendSummaryToSetfeed);
    btnSendSummary2.addEventListener("click", sendSummaryToSetfeed);

    // -------------------------
    // Realtime rendering
    // -------------------------
    function renderState(nextState) {
      state = nextState || "—";
      statePill.textContent = state;

      if (state === "LOBBY") hint.textContent = "Ready up. When everyone is ready, the host begins the pulse window.";
      else if (state === "RUNNING") hint.textContent = "Pulse fast. Preview is anonymous. Chat opens during cooldown.";
      else if (state === "COOLDOWN") hint.textContent = "Cooldown (5 minutes). Ask who sent what. Summary is preparing.";
      else if (state === "DONE") hint.textContent = "Done. Summary is ready.";
      else if (state === "CANCELLED") hint.textContent = "This lobby expired before it started.";
      else hint.textContent = "—";

      setHidden(composer, state !== "RUNNING");

      const chatOpen = (state === "COOLDOWN" || state === "DONE");
      chatText.disabled = !chatOpen;
      btnChat.disabled = !chatOpen;
      chatMeta.textContent = chatOpen ? "Open" : "Opens in cooldown";

      refreshSetfeedUI();
    }

    function renderCountdown() {
      if (!session) { countdownEl.textContent = ""; return; }

      const now = Date.now();
      if (state === "RUNNING" && session.endAtMillis) {
        const left = session.endAtMillis - now;
        countdownEl.textContent = left > 0 ? `RUNNING · ${fmtMs(left)}` : "RUNNING · 00:00";
      } else if (state === "COOLDOWN" && session.cooldownEndsAtMillis) {
        const left = session.cooldownEndsAtMillis - now;
        countdownEl.textContent = left > 0 ? `COOLDOWN · ${fmtMs(left)}` : "COOLDOWN · 00:00";
      } else if (state === "LOBBY" && session.reservationExpiresAtMillis) {
        const left = session.reservationExpiresAtMillis - now;
        countdownEl.textContent = left > 0 ? `LOBBY · ${fmtMs(left)}` : "LOBBY · 00:00";
      } else {
        countdownEl.textContent = state;
      }
    }

    async function getDownloadUrl(storagePath) {
      const cached = downloadUrlCache.get(storagePath);
      const now = Date.now();
      if (cached && cached.exp && now < cached.exp - 20_000) return cached.url;

      const call = functions.httpsCallable("delveeCreateImageDownloadUrl");
      const res = await call({ sessionId, storagePath });
      const url = res.data?.downloadUrl;
      const exp = res.data?.expiresAtMillis;
      if (url) downloadUrlCache.set(storagePath, { url, exp: exp || (now + 240_000) });
      return url || null;
    }

    function renderParticipants(list) {
      list.sort((a,b) => String(a.aliasLower||"").localeCompare(String(b.aliasLower||"")));

      const meUid = auth.currentUser?.uid || "";
      const frag = document.createDocumentFragment();

      for (const p of list) {
        const row = document.createElement("div");
        row.className = "dv-person";

        const left = document.createElement("div");
        left.className = "dv-person-left";

        const name = document.createElement("div");
        name.className = "dv-person-name";
        name.textContent = p.alias || "—";

        const meta = document.createElement("div");
        meta.className = "dv-person-meta";
        const ready = p.ready ? "ready" : "not ready";
        const pulses = typeof p.pulsesCount === "number" ? p.pulsesCount : 0;
        meta.textContent = `${ready} · ${pulses} pulses`;

        left.appendChild(name);
        left.appendChild(meta);

        const badge = document.createElement("div");
        badge.className = "dv-badge";
        badge.textContent = p.ready ? "✓" : "·";

        if (p.uid === meUid) {
          row.classList.add("me");
          badge.classList.add("me");
        }

        row.appendChild(left);
        row.appendChild(badge);
        frag.appendChild(row);
      }

      participantsEl.innerHTML = "";
      participantsEl.appendChild(frag);
    }

    async function renderFeed(items) {
      feedMeta.textContent = `${items.length} pulses`;
      const frag = document.createDocumentFragment();

      for (const it of items) {
        const card = document.createElement("div");
        card.className = "dv-pulse";

        const kind = document.createElement("div");
        kind.className = "dv-pulse-kind";
        kind.textContent = it.kind === "image" ? "image" : "text";
        card.appendChild(kind);

        if (it.kind === "text") {
          const body = document.createElement("div");
          body.className = "dv-pulse-text";
          body.textContent = it.text || "";
          card.appendChild(body);
        } else if (it.kind === "image" && it.attachment && it.attachment.storagePath) {
          const imgWrap = document.createElement("div");
          imgWrap.className = "dv-pulse-imgwrap";

          const img = document.createElement("img");
          img.className = "dv-pulse-img";
          img.alt = "Pulse image";

          imgWrap.appendChild(img);
          card.appendChild(imgWrap);

          getDownloadUrl(it.attachment.storagePath)
            .then((url) => { if (url) img.src = url; })
            .catch(() => {});
        }

        frag.appendChild(card);
      }

      feed.innerHTML = "";
      feed.appendChild(frag);
      feed.scrollTop = feed.scrollHeight;
    }

    function renderChat(items) {
      const frag = document.createDocumentFragment();
      for (const m of items) {
        const row = document.createElement("div");
        row.className = "dv-chat-msg";
        row.innerHTML = `<div class="dv-chat-text">${escapeHtml(m.text || "")}</div>`;
        frag.appendChild(row);
      }
      chat.innerHTML = "";
      chat.appendChild(frag);
      chat.scrollTop = chat.scrollHeight;
    }

    function renderSummaryIfReady() {
      const has = !!(session && session.summaryText);
      setHidden(summaryPanel, !(state === "DONE" && has));
      if (state === "DONE" && has) {
        summaryTextEl.textContent = session.summaryText || "";
        const gen = session.summaryStats && session.summaryStats.generatedAtUtc ? session.summaryStats.generatedAtUtc : (session.summaryReadyAtUtc || "—");
        summaryMeta.textContent = `Generated: ${gen}`;
      }
      refreshSetfeedUI();
    }

    async function maybeAutoSend() {
      if (!getAutosend()) return;
      if (hasSentForThisSession()) return;
      const code = (setfeedCodeInput.value || "").trim();
      if (!code) return;
      if (!(state === "DONE" && session && session.summaryText)) return;
      await sendSummaryToSetfeed();
    }

    // -------------------------
    // Boot: ensure signed in + join
    // -------------------------
    async function boot() {
      if (!sessionId) return;

      setStatus("good", "Connecting…", "Signing in and joining the session.");

      const user = auth.currentUser;
      if (!user) {
        setStatus("warn", "Sign in required", "Return to home and sign in first.");
        setTimeout(() => window.location.href = "./index.html", 800);
        return;
      }

      if (!myAlias) {
        setStatus("warn", "Alias missing", "Return to home and set an alias.");
        setTimeout(() => window.location.href = "./index.html", 800);
        return;
      }

      try {
        const join = functions.httpsCallable("delveeJoinSession");
        await join({ sessionId, alias: myAlias });
      } catch (e) {
        console.error(e);
        setStatus("warn", "Couldn’t join", (e && e.message) ? e.message : "Try again.");
        return;
      }

      setStatus("good", "Connected", "Realtime lobby active.");

      unsub.push(
        sref.onSnapshot((snap) => {
          const d = snap.data() || {};
          session = d;

          const st = d.state || "—";
          renderState(st);

          isHost = (d.hostUid && auth.currentUser && d.hostUid === auth.currentUser.uid);
          setHidden(hostControls, !isHost);

          renderCountdown();
          renderSummaryIfReady();

          maybeAutoSend().catch(() => {});
        }, (err) => {
          console.error(err);
          setStatus("warn", "Realtime blocked", "Check Firestore rules for Delvee participant reads.");
        })
      );

      unsub.push(
        pref.doc(auth.currentUser.uid).onSnapshot((snap) => {
          me = snap.data() || null;
          const ready = !!(me && me.ready);
          btnReady.textContent = ready ? "Unready" : "Ready";
        })
      );

      unsub.push(
        pref.onSnapshot((snap) => {
          const list = snap.docs.map(d => d.data());
          renderParticipants(list);
        })
      );

      unsub.push(
        pulsesRef.orderBy("createdAtMillis", "asc").limit(250).onSnapshot((snap) => {
          const list = snap.docs.map(d => d.data());
          renderFeed(list);
        })
      );

      unsub.push(
        chatRef.orderBy("createdAtMillis", "asc").limit(200).onSnapshot((snap) => {
          const list = snap.docs.map(d => d.data());
          renderChat(list);
        })
      );

      setInterval(renderCountdown, 500);
      refreshSetfeedUI();
    }

    auth.onAuthStateChanged(() => boot());

    window.addEventListener("beforeunload", () => {
      for (const u of unsub) try { u(); } catch (_) {}
      unsub = [];
    });
  </script>
</body>
</html>

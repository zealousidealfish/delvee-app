<!-- delvee/lobby.html (FULL FILE REPLACEMENT) -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Lobby — Delvee</title>
  <meta name="theme-color" content="#0F1114" id="meta-theme-color" />

  <link rel="stylesheet" href="./styles.css" />

  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-functions-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>

  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyCECKG-00tijJrt5qvRy3L27ZzE7bocNrU",
      authDomain: "setfeed-fcd7a.firebaseapp.com",
      projectId: "setfeed-fcd7a",
      storageBucket: "setfeed-fcd7a.firebasestorage.app",
      messagingSenderId: "553573263069",
      appId: "1:553573263069:web:e5c9884101ca38eaee1d34"
    };

    if (!firebase.apps || firebase.apps.length === 0) firebase.initializeApp(firebaseConfig);

    const auth = firebase.auth();
    const functions = firebase.app().functions("europe-west2");
    const db = firebase.firestore();
  </script>

  <!-- Theme (Lobby defaults to DARK if nothing set; does not overwrite storage) -->
  <script>
    (function(){
      const THEME_KEY = "sf_theme_mode";
      const root = document.documentElement;

      function readStoredRaw(){
        try { return localStorage.getItem(THEME_KEY); } catch (_) { return null; }
      }

      function applyTheme(){
        const storedRaw = readStoredRaw();
        const stored = storedRaw || "system";

        if (!storedRaw) {
          root.setAttribute("data-theme", "dark");
        } else if (stored === "light" || stored === "dark") {
          root.setAttribute("data-theme", stored);
        } else {
          root.removeAttribute("data-theme");
        }

        const effective =
          root.getAttribute("data-theme") ||
          (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light");

        const meta = document.getElementById("meta-theme-color");
        if (meta) meta.content = (effective === "dark") ? "#0F1114" : "#FFFBFE";
      }

      function setToggleLabel(){
        const btn = document.getElementById("themeToggle");
        if (!btn) return;

        const storedRaw = readStoredRaw();
        const stored = storedRaw || "system";

        const effective =
          (!storedRaw) ? "dark" :
          (stored === "light" || stored === "dark") ? stored :
          (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light");

        btn.textContent = effective === "dark" ? "Light" : "Dark";
        btn.setAttribute("aria-label", effective === "dark" ? "Switch to light theme" : "Switch to dark theme");
      }

      function wireToggle(){
        const btn = document.getElementById("themeToggle");
        if (!btn) return;

        btn.addEventListener("click", () => {
          const storedRaw = readStoredRaw();
          const stored = storedRaw || "system";

          const effective =
            (!storedRaw) ? "dark" :
            (stored === "light" || stored === "dark") ? stored :
            (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light");

          const next = (effective === "dark") ? "light" : "dark";
          try { localStorage.setItem(THEME_KEY, next); } catch (_) {}
          applyTheme();
          setToggleLabel();
        });

        if (window.matchMedia) {
          const mq = window.matchMedia("(prefers-color-scheme: dark)");
          try {
            mq.addEventListener("change", () => { applyTheme(); setToggleLabel(); });
          } catch (_) {}
        }
      }

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", () => {
          applyTheme();
          setToggleLabel();
          wireToggle();
        }, { once: true });
      } else {
        applyTheme();
        setToggleLabel();
        wireToggle();
      }

      window.addEventListener("storage", (e) => {
        if (e && e.key === THEME_KEY) { applyTheme(); setToggleLabel(); }
      });
    })();
  </script>

  <style>
    /* Keep your existing local additions */
    .dv-summary {
      margin-top: 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.05);
      padding: 12px;
    }
    .dv-summary h3{
      margin: 0 0 8px 0;
      font-size: 14px;
      font-weight: 500;
      opacity: 0.92;
      letter-spacing: 0.1px;
    }
    .dv-summary pre{
      margin: 0;
      white-space: pre-wrap;
      word-break: break-word;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12.5px;
      line-height: 1.35;
      color: rgba(233,238,246,0.92);
    }
    .dv-minirow { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top: 10px; }
    .dv-input {
      width: 100%;
      border-radius: 12px;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(15,17,20,0.55);
      color: rgba(233,238,246,0.92);
      outline: none;
    }
    .dv-muted2 { font-size: 12px; color: rgba(233,238,246,0.70); line-height: 1.35; }

    .dv-file{ display:none !important; }
    .dv-file-chip{
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: rgba(233,238,246,0.92);
      font: inherit;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
    }
    .dv-file-chip:active{ transform: translateY(1px); opacity: 0.95; }
    .dv-file-dot{
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: rgba(233,238,246,0.55);
      flex: 0 0 auto;
    }
    .dv-file-name{
      max-width: 240px;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .dv-file-clear{
      border: 0;
      background: transparent;
      color: rgba(233,238,246,0.75);
      padding: 0;
      margin-left: 2px;
      cursor: pointer;
      font: inherit;
      line-height: 1;
    }
    .dv-file-clear:hover{ color: rgba(233,238,246,0.92); }

    /* ✅ Slightly more space between duration dropdown and Start button */
    .dv-host{ display:flex; align-items:center; gap: 12px; }

    /* ✅ “Close lobby” button emphasis */
    .dv-btn-danger{
      border-color: rgba(255,255,255,0.16);
      background: rgba(255,60,60,0.16);
    }
    .dv-btn-danger:hover{ background: rgba(255,60,60,0.22); }

    /* ✅ Attribution modal */
    .dv-modal-backdrop{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      z-index: 60;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 18px;
    }
    .dv-modal-backdrop.show{ display:flex; }
    .dv-modal{
      width: min(520px, 100%);
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(15,17,20,0.92);
      box-shadow: 0 24px 70px rgba(0,0,0,0.55);
      padding: 14px;
    }
    .dv-modal h3{
      margin: 0 0 8px 0;
      font-size: 14px;
      font-weight: 520;
      color: rgba(233,238,246,0.92);
    }
    .dv-modal .dv-muted2{ margin-top: 6px; }
    .dv-modal-list{
      margin-top: 10px;
      display:flex;
      flex-wrap:wrap;
      gap: 8px;
    }
    .dv-modal-actions{
      display:flex;
      gap:10px;
      justify-content:flex-end;
      margin-top: 12px;
    }

    /* ---------------------------------------------
       ✅ Compact alias/message layout (matches screenshot vibe)
       --------------------------------------------- */
    .dv-chat-msg{
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.04);
      padding: 10px 12px;
      margin-bottom: 10px;
    }
    .dv-chat-alias{
      font-size: 12px;
      opacity: 0.72;
      margin-bottom: 6px;
      letter-spacing: 0.2px;
    }
    .dv-chat-body{
      font-size: 14px;
      line-height: 1.25;
      opacity: 0.92;
    }

    /* ---------------------------------------------
       ✅ Pulse cards: reduce vertical height + selected highlight
       --------------------------------------------- */
    .dv-pulse{
      padding: 10px 12px !important;
      border-radius: 16px !important;
    }
    .dv-pulse-kind{
      font-size: 11px !important;
      opacity: 0.70 !important;
      margin-bottom: 6px !important;
    }
    .dv-pulse-text{
      font-size: 14px !important;
      line-height: 1.25 !important;
    }
    .dv-pulse.selected{
      outline: 2px solid rgba(140, 160, 255, 0.55);
      background: rgba(140, 160, 255, 0.08);
    }

    /* ---------------------------------------------
       ✅ Prep Phase overlay
       --------------------------------------------- */
    .dv-prep-overlay{
      position:fixed; inset:0; z-index:1000;
      background: rgba(0,0,0,0.86);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
    }
    .dv-prep-overlay.show{ display:flex; }

    .dv-prep-inner{
      width: min(980px, 100%);
      max-height: calc(100vh - 36px);
      overflow: hidden;
      border-radius: 20px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(15,17,20,0.94);
      box-shadow: 0 26px 80px rgba(0,0,0,0.6);
      padding: 16px;
      display:flex;
      flex-direction:column;
      gap: 12px;
    }
    .dv-prep-head{
      display:flex;
      align-items:flex-end;
      gap: 14px;
      justify-content:space-between;
    }
    .dv-prep-title{
      font-size: 18px;
      font-weight: 650;
      letter-spacing: 0.2px;
    }
    .dv-prep-sub{
      margin-top: 4px;
      font-size: 12px;
      opacity: 0.78;
      line-height: 1.35;
    }
    .dv-prep-timer{
      text-align:right;
      min-width: 140px;
    }
    .dv-prep-timer .label{
      font-size: 12px;
      opacity: 0.72;
    }
    .dv-prep-timer .value{
      margin-top: 2px;
      font-size: 34px;
      font-weight: 800;
      letter-spacing: 0.5px;
    }

    .dv-prep-actions{
      display:flex;
      align-items:center;
      gap: 10px;
      flex-wrap:wrap;
    }
    .dv-prep-count{
      margin-left:auto;
      font-size: 12px;
      opacity: 0.8;
      white-space: nowrap;
    }

    .dv-prep-grid{
      border-top: 1px solid rgba(255,255,255,0.08);
      border-bottom: 1px solid rgba(255,255,255,0.08);
      padding: 12px 2px;
      overflow:auto;
      display:grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 10px;
      min-height: 200px;
    }
    .dv-prep-tile{
      border-radius: 16px;
      overflow:hidden;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.04);
      display:flex;
      flex-direction:column;
    }
    .dv-prep-thumb{
      width:100%;
      aspect-ratio: 1/1;
      object-fit: cover;
      display:block;
    }
    .dv-prep-meta{
      padding: 8px 10px;
      display:flex;
      align-items:center;
      gap: 8px;
    }
    .dv-prep-name{
      flex: 1;
      font-size: 12px;
      opacity: 0.85;
      overflow:hidden;
      white-space:nowrap;
      text-overflow:ellipsis;
    }
    .dv-prep-remove{
      border: 0;
      background: rgba(255,255,255,0.10);
      color: rgba(233,238,246,0.92);
      border-radius: 10px;
      padding: 6px 8px;
      cursor:pointer;
    }

    .dv-prep-foot{
      display:flex;
      align-items:center;
      gap: 10px;
    }
    .dv-prep-hint{
      flex:1;
      font-size: 12px;
      opacity: 0.75;
      line-height: 1.35;
    }

    /* ---------------------------------------------
       ✅ Summary vault reveal modal (ready / set / reveal)
       --------------------------------------------- */
    .dv-vault{
      position:fixed; inset:0; z-index:1100;
      background: rgba(0,0,0,0.78);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
    }
    .dv-vault.show{ display:flex; }
    .dv-vault-inner{
      width: min(980px, 100%);
      max-height: calc(100vh - 36px);
      overflow:hidden;
      border-radius: 22px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(15,17,20,0.94);
      box-shadow: 0 26px 90px rgba(0,0,0,0.65);
      position:relative;
    }
    .dv-vault-topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }
    .dv-vault-title{
      font-weight: 650;
      letter-spacing: 0.2px;
      opacity: 0.92;
    }
    .dv-vault-stage{
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 44px 14px;
      position:relative;
      overflow:hidden;
    }
    .dv-vault-stage::before{
      content:"";
      position:absolute; inset:-40%;
      background:
        radial-gradient(circle at 30% 30%, rgba(140,160,255,0.20), transparent 55%),
        radial-gradient(circle at 70% 60%, rgba(255,255,255,0.10), transparent 60%),
        linear-gradient(90deg, transparent, rgba(255,255,255,0.06), transparent);
      filter: blur(0px);
      animation: dvVaultDrift 3.2s linear infinite;
      opacity: 0.85;
    }
    @keyframes dvVaultDrift{
      0%{ transform: translateX(-10%) translateY(-3%) rotate(0deg); }
      100%{ transform: translateX(10%) translateY(3%) rotate(6deg); }
    }
    .dv-vault-word{
      position:relative;
      font-size: 42px;
      font-weight: 900;
      letter-spacing: 1.2px;
      text-transform: lowercase;
      color: rgba(233,238,246,0.95);
      text-shadow: 0 10px 28px rgba(0,0,0,0.55);
      animation: dvWordPop 540ms ease both;
    }
    @keyframes dvWordPop{
      0%{ transform: translateY(10px); opacity: 0; }
      100%{ transform: translateY(0); opacity: 1; }
    }

    .dv-vault-content{
      display:none;
      padding: 14px;
    }
    .dv-vault-content.show{ display:block; }

    .dv-vault-scroll{
      max-height: calc(100vh - 210px);
      overflow:auto;
      padding-right: 6px;
    }

    .dv-vault-grid2{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }

    .dv-collage-row{
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
      align-items:center;
      margin-top: 10px;
    }

    /* Small helper button */
    .dv-btn-secondary{
      background: rgba(255,255,255,0.06);
      border-color: rgba(255,255,255,0.14);
    }
  </style>
</head>

<body class="dv-bg">
  <header class="dv-top">
    <div class="dv-top-inner">
      <div class="dv-brand">
        <a class="dv-mark" href="./index.html" aria-label="Delvee home"></a>
        <div>
          <div class="dv-title">Delvee</div>
          <div class="dv-sub" id="sessionLabel">Lobby</div>
        </div>
      </div>

      <div class="dv-top-actions">
        <button class="dv-theme-toggle" id="themeToggle" type="button">Theme</button>
        <button class="dv-chip" id="btn-copy" type="button">Copy code</button>
        <button class="dv-chip" id="btn-home" type="button">Home</button>
        <button class="dv-chip" id="btn-leave" type="button">Leave</button>
      </div>
    </div>
  </header>

  <main class="dv-wrap dv-wrap-wide">
    <section class="dv-card dv-card-wide">

      <div class="dv-status dv-status-tight" id="status">
        <span class="dv-dot" id="statusDot"></span>
        <div>
          <div class="dv-status-title" id="statusTitle">Connecting…</div>
          <div class="dv-status-line" id="statusLine">Preparing realtime lobby.</div>
        </div>
        <div class="dv-right" id="countdown"></div>
      </div>

      <div class="dv-layout">
        <!-- Left: participants -->
        <aside class="dv-side">
          <div class="dv-panel">
            <div class="dv-panel-head">
              <h2 class="dv-h2">Participants</h2>
              <div class="dv-pill" id="statePill">—</div>
            </div>

            <div class="dv-list" id="participants"></div>

            <div class="dv-hr"></div>

            <div class="dv-actions dv-actions-compact">
              <button class="dv-btn" id="btn-ready" type="button">Ready</button>

              <div class="dv-host hidden" id="hostControls">
                <select id="duration" class="dv-select" aria-label="Duration">
                  <option value="4">4 min</option>
                  <option value="5">5 min</option>
                </select>

                <button class="dv-btn dv-btn-primary" id="btn-start" type="button">Start</button>

                <!-- ✅ Stop button during RUNNING (requires server callable delveeStopSession) -->
                <button class="dv-btn hidden" id="btn-stop" type="button">Stop</button>
              </div>
            </div>

            <p class="dv-help" id="hint">
              This is the threshold. Ready means you’re in. The host begins the window.
            </p>

            <!-- ✅ Account-based Setfeed delivery (preferred) + fallback to manual code -->
            <div class="dv-summary" id="setfeedPanel">
              <h3>Setfeed summary delivery</h3>

              <div id="setfeedAccountBox" class="dv-muted2" style="margin-bottom:10px;">
                Sign in with Google to send summaries to your account inbox automatically (web + app).
              </div>

              <div id="setfeedCodeBox">
                <input class="dv-input" id="setfeedCode" placeholder="Paste your Setfeed receive code (SF-… or SFS-…)" />
              </div>

              <div class="dv-minirow">
                <button class="dv-btn" id="btn-toggle-autosend" type="button">Auto-send: Off</button>
                <button class="dv-btn dv-btn-primary" id="btn-send-summary" type="button" disabled>Send summary</button>
              </div>

              <div class="dv-muted2" id="setfeedStatus">Tip: summary encrypts locally and sends to your inbox.</div>

              <!-- ✅ Close lobby (appears 2 minutes after summary generated) -->
              <div class="dv-minirow">
                <button class="dv-btn dv-btn-danger hidden" id="btn-close-lobby" type="button">Close lobby</button>
              </div>
              <div class="dv-muted2 hidden" id="closeLobbyHint">
                This destroys the lobby session in Firestore. (Requires server callable: <code>delveeCloseLobby</code>)
              </div>
            </div>
          </div>
        </aside>

        <!-- Center: live feed + composer -->
        <section class="dv-main">
          <div class="dv-panel">
            <div class="dv-panel-head">
              <h2 class="dv-h2">Live preview</h2>
              <div class="dv-muted" id="feedMeta">—</div>
            </div>

            <div class="dv-feed" id="feed"></div>

            <div class="dv-composer" id="composer">
              <div class="dv-compose-row">
                <textarea id="pulseText" maxlength="100" placeholder="Write a pulse (≤100 chars)"></textarea>
                <button class="dv-btn dv-btn-primary" id="btn-pulse" type="button">Pulse</button>
              </div>

              <div class="dv-compose-row dv-compose-row2">
                <input class="dv-file" id="pulseImage" type="file" accept="image/*" />

                <button class="dv-file-chip" id="btn-choose-image" type="button" aria-label="Choose image">
                  <span class="dv-file-dot" aria-hidden="true"></span>
                  <span id="dv-file-chip-label">Choose image</span>
                </button>

                <button class="dv-btn dv-btn-secondary" id="btn-from-prep" type="button">From prep queue</button>
                <button class="dv-btn" id="btn-image" type="button">Pulse image</button>
              </div>

              <div class="dv-help dv-help-tight" id="composerHelp">
                Fast, short, deliberate. Throttling is enforced.
              </div>
            </div>

            <!-- ✅ Summary is NO LONGER shown at the bottom.
                It appears in the vault modal overlay after the reveal animation. -->
          </div>
        </section>

        <!-- Right: chat (cooldown/done only) -->
        <aside class="dv-side">
          <div class="dv-panel">
            <div class="dv-panel-head">
              <h2 class="dv-h2">Chat</h2>
              <div class="dv-muted" id="chatMeta">Opens in cooldown</div>
            </div>

            <div class="dv-chat" id="chat"></div>

            <div class="dv-chatbox">
              <input id="chatText" maxlength="300" placeholder="Ask who sent what…" />
              <button class="dv-btn" id="btn-chat" type="button">Send</button>
            </div>

            <div class="dv-help dv-help-tight">
              Chat is for attribution guesses — not discussion.
            </div>
          </div>
        </aside>
      </div>

    </section>
  </main>

  <!-- ✅ Attribution modal -->
  <div class="dv-modal-backdrop" id="guessBackdrop" role="dialog" aria-modal="true" aria-label="Choose sender">
    <div class="dv-modal">
      <h3>Who do you think sent this?</h3>
      <div class="dv-muted2" id="guessPreview">—</div>
      <div class="dv-modal-list" id="guessList"></div>
      <div class="dv-modal-actions">
        <button class="dv-btn" id="guessClear" type="button">Clear</button>
        <button class="dv-btn dv-btn-primary" id="guessClose" type="button">Done</button>
      </div>
      <div class="dv-muted2" style="margin-top:10px;">
        Your guesses are scored in the summary as “correct predictions”.
      </div>
    </div>
  </div>

  <!-- ✅ Prep Phase Overlay -->
  <div class="dv-prep-overlay" id="dvPrepOverlay" role="dialog" aria-modal="true" aria-label="Preparation phase">
    <div class="dv-prep-inner">
      <div class="dv-prep-head">
        <div>
          <div class="dv-prep-title">Prepare your images</div>
          <div class="dv-prep-sub">
            Add up to <span id="dvPrepMaxA">20</span> images now, then pulse them quickly during the session.
            (Frontend-only prototype)
          </div>
        </div>
        <div class="dv-prep-timer">
          <div class="label">Preparation</div>
          <div class="value" id="dvPrepCountdown">03:00</div>
        </div>
      </div>

      <div class="dv-prep-actions">
        <input id="dvPrepFileMulti" class="dv-file" type="file" accept="image/*" multiple />
        <input id="dvPrepFileSingle" class="dv-file" type="file" accept="image/*" />

        <button class="dv-btn dv-btn-primary" id="dvPrepAddMulti" type="button">Add images</button>
        <button class="dv-btn" id="dvPrepAddOne" type="button">Add one</button>
        <button class="dv-btn dv-btn-secondary" id="dvPrepClear" type="button">Clear all</button>

        <div class="dv-prep-count">
          <span id="dvPrepCount">0</span>/<span id="dvPrepMaxB">20</span>
        </div>
      </div>

      <div class="dv-prep-grid" id="dvPrepGrid"></div>

      <div class="dv-prep-foot">
        <div class="dv-prep-hint">
          You can also attach from this queue during RUNNING using “From prep queue”.
        </div>
        <button class="dv-btn" id="dvPrepClose" type="button">Hide</button>
      </div>
    </div>
  </div>

  <!-- ✅ “From prep queue” picker -->
  <div class="dv-modal-backdrop" id="dvPrepPickerBackdrop" role="dialog" aria-modal="true" aria-label="Prep queue picker">
    <div class="dv-modal" style="width:min(720px,100%);">
      <h3>Select a queued image</h3>
      <div class="dv-muted2" style="margin-top:6px;">Tap an image to attach it for pulsing.</div>
      <div id="dvPrepPickerGrid" style="margin-top:12px; display:grid; grid-template-columns:repeat(auto-fill,minmax(120px,1fr)); gap:10px; max-height:52vh; overflow:auto; padding-right:6px;"></div>
      <div class="dv-modal-actions">
        <button class="dv-btn" id="dvPrepPickerClose" type="button">Close</button>
      </div>
    </div>
  </div>

  <!-- ✅ Summary Vault Modal -->
  <div class="dv-vault" id="dvSummaryVault" role="dialog" aria-modal="true" aria-label="Session summary">
    <div class="dv-vault-inner">
      <div class="dv-vault-topbar">
        <div class="dv-vault-title">Session summary</div>
        <div style="display:flex; gap:10px; align-items:center;">
          <button class="dv-btn dv-btn-secondary" id="btnDownloadCollage" type="button" disabled>Download collage</button>
          <button class="dv-btn" id="dvVaultClose" type="button">Close</button>
        </div>
      </div>

      <!-- Reveal stage -->
      <div class="dv-vault-stage" id="dvVaultStage">
        <div class="dv-vault-word" id="dvVaultWord">ready.</div>
      </div>

      <!-- Content -->
      <div class="dv-vault-content" id="dvVaultContent">
        <div class="dv-vault-scroll">
          <div class="dv-vault-grid2">
            <div class="dv-summary" style="margin-top:0;">
              <h3>Summary</h3>
              <pre id="summaryText">—</pre>

              <div class="dv-muted2" id="summaryScore" style="margin-top:10px;"></div>
              <div class="dv-muted2" id="summaryMeta" style="margin-top:6px;">Generated on DONE.</div>

              <div class="dv-minirow">
                <button class="dv-btn dv-btn-primary" id="btn-send-summary-2" type="button" disabled>Send to Setfeed</button>
              </div>
            </div>

            <div class="dv-summary">
              <h3>Messages by participant</h3>
              <pre id="summaryByAlias">—</pre>
            </div>
          </div>
        </div>

        <div class="dv-collage-row" style="padding: 12px 14px; border-top:1px solid rgba(255,255,255,0.08);">
          <div class="dv-muted2" id="collageStatus">Collage will include summary text + session images.</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // -------------------------
    // Utilities
    // -------------------------
    const qs = new URLSearchParams(window.location.search);
    const sessionId = (qs.get("session") || "").trim().toUpperCase();

    const ALIAS_KEY = "dv_alias";
    const LAST_SESSION_KEY = "dv_last_session";

    const SETFEED_CODE_KEY = "dv_setfeed_receive_code";
    const SETFEED_AUTOSEND_KEY = "dv_setfeed_autosend";

    const SENT_FLAG_KEY = `dv_setfeed_summary_sent_${sessionId}`;

    // ✅ Predictions storage (per session)
    const PRED_KEY = `dv_predictions_${sessionId}`; // { [pulseId]: { guessedUid, guessedAlias } }

    // ✅ Frontend-only: PREP + cooldown overrides
    const DV_PREP_MS = 3 * 60 * 1000;     // 3 minutes
    const DV_COOLDOWN_MS = 3 * 60 * 1000; // 3 minutes (frontend display/prototype)
    const DV_PREP_MAX_IMAGES = 20;

    const PREP_DONE_KEY = `dv_prep_done_${sessionId}`;
    const PREP_IMAGES_KEY = `dv_prep_images_${sessionId}`;

    function getAlias() {
      try { return (localStorage.getItem(ALIAS_KEY) || "").trim(); } catch (_) { return ""; }
    }
    function setAlias(a) {
      try { localStorage.setItem(ALIAS_KEY, String(a || "").trim()); } catch (_) {}
    }

    function setLastSession(sid) {
      try { localStorage.setItem(LAST_SESSION_KEY, String(sid || "").trim().toUpperCase()); } catch (_) {}
    }

    function setStatus(kind, title, line) {
      const dot = document.getElementById("statusDot");
      const t = document.getElementById("statusTitle");
      const l = document.getElementById("statusLine");
      dot.className = "dv-dot";
      if (kind === "good") dot.classList.add("good");
      if (kind === "warn") dot.classList.add("warn");
      t.textContent = title;
      l.textContent = line;
    }

    function fmtMs(ms) {
      const s = Math.max(0, Math.floor(ms / 1000));
      const mm = String(Math.floor(s / 60)).padStart(2, "0");
      const ss = String(s % 60).padStart(2, "0");
      return `${mm}:${ss}`;
    }

    function randomId(prefix) {
      return `${prefix}_${Date.now()}_${Math.random().toString(16).slice(2)}`;
    }

    function escapeHtml(s) {
      return String(s || "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;");
    }

    function setHidden(el, hidden) {
      if (!el) return;
      el.classList.toggle("hidden", !!hidden);
    }

    function isGoogleUser(u){
      if (!u) return false;
      const prov = (u.providerData || []).map(p => p && p.providerId).filter(Boolean);
      return prov.includes("google.com");
    }

    function isAnon(u){
      return !!(u && u.isAnonymous);
    }

    function loadPredictions(){
      try { return JSON.parse(localStorage.getItem(PRED_KEY) || "{}") || {}; } catch (_) { return {}; }
    }
    function savePredictions(obj){
      try { localStorage.setItem(PRED_KEY, JSON.stringify(obj || {})); } catch (_) {}
    }

    if (!sessionId) {
      setStatus("warn", "Missing session", "Open a lobby from Delvee home or a join link.");
      setTimeout(() => window.location.href = "./index.html", 700);
    } else {
      setLastSession(sessionId);
    }

    document.getElementById("sessionLabel").textContent = sessionId ? `Session ${sessionId}` : "Lobby";

    // -------------------------
    // Elements
    // -------------------------
    const btnCopy = document.getElementById("btn-copy");
    const btnLeave = document.getElementById("btn-leave");
    const btnHome = document.getElementById("btn-home");

    const participantsEl = document.getElementById("participants");
    const statePill = document.getElementById("statePill");
    const hint = document.getElementById("hint");

    const btnReady = document.getElementById("btn-ready");
    const hostControls = document.getElementById("hostControls");
    const btnStart = document.getElementById("btn-start");
    const btnStop = document.getElementById("btn-stop");
    const durationSel = document.getElementById("duration");

    const countdownEl = document.getElementById("countdown");

    const feed = document.getElementById("feed");
    const feedMeta = document.getElementById("feedMeta");

    const composer = document.getElementById("composer");
    const pulseText = document.getElementById("pulseText");
    const btnPulse = document.getElementById("btn-pulse");
    const pulseImage = document.getElementById("pulseImage");
    const btnImage = document.getElementById("btn-image");
    const composerHelp = document.getElementById("composerHelp");

    const btnChooseImage = document.getElementById("btn-choose-image");
    const chipLabel = document.getElementById("dv-file-chip-label");
    const btnFromPrep = document.getElementById("btn-from-prep");

    const chat = document.getElementById("chat");
    const chatText = document.getElementById("chatText");
    const btnChat = document.getElementById("btn-chat");
    const chatMeta = document.getElementById("chatMeta");

    const btnSendSummary = document.getElementById("btn-send-summary");
    const btnSendSummary2 = document.getElementById("btn-send-summary-2");

    const setfeedAccountBox = document.getElementById("setfeedAccountBox");
    const setfeedCodeBox = document.getElementById("setfeedCodeBox");
    const setfeedCodeInput = document.getElementById("setfeedCode");
    const btnToggleAutosend = document.getElementById("btn-toggle-autosend");
    const setfeedStatus = document.getElementById("setfeedStatus");

    const btnCloseLobby = document.getElementById("btn-close-lobby");
    const closeLobbyHint = document.getElementById("closeLobbyHint");

    // Guess modal
    const guessBackdrop = document.getElementById("guessBackdrop");
    const guessPreview = document.getElementById("guessPreview");
    const guessList = document.getElementById("guessList");
    const guessClose = document.getElementById("guessClose");
    const guessClear = document.getElementById("guessClear");

    // Prep overlay
    const dvPrepOverlay = document.getElementById("dvPrepOverlay");
    const dvPrepCountdownEl = document.getElementById("dvPrepCountdown");
    const dvPrepGrid = document.getElementById("dvPrepGrid");
    const dvPrepCount = document.getElementById("dvPrepCount");
    const dvPrepAddMulti = document.getElementById("dvPrepAddMulti");
    const dvPrepAddOne = document.getElementById("dvPrepAddOne");
    const dvPrepClear = document.getElementById("dvPrepClear");
    const dvPrepClose = document.getElementById("dvPrepClose");
    const dvPrepFileMulti = document.getElementById("dvPrepFileMulti");
    const dvPrepFileSingle = document.getElementById("dvPrepFileSingle");

    // Prep picker
    const dvPrepPickerBackdrop = document.getElementById("dvPrepPickerBackdrop");
    const dvPrepPickerGrid = document.getElementById("dvPrepPickerGrid");
    const dvPrepPickerClose = document.getElementById("dvPrepPickerClose");

    // Summary vault
    const dvSummaryVault = document.getElementById("dvSummaryVault");
    const dvVaultClose = document.getElementById("dvVaultClose");
    const dvVaultStage = document.getElementById("dvVaultStage");
    const dvVaultWord = document.getElementById("dvVaultWord");
    const dvVaultContent = document.getElementById("dvVaultContent");

    const summaryTextEl = document.getElementById("summaryText");
    const summaryMeta = document.getElementById("summaryMeta");
    const summaryScore = document.getElementById("summaryScore");
    const summaryByAliasEl = document.getElementById("summaryByAlias");

    const btnDownloadCollage = document.getElementById("btnDownloadCollage");
    const collageStatus = document.getElementById("collageStatus");

    // -------------------------
    // Firestore refs
    // -------------------------
    const sref = db.collection("delvee_sessions").doc(sessionId);
    const pref = sref.collection("participants");
    const pulsesRef = sref.collection("pulses");
    const chatRef = sref.collection("chat");

    // -------------------------
    // Local state
    // -------------------------
    let unsub = [];
    let session = null;
    let me = null;
    let isHost = false;
    let state = "—";

    let pendingTextPulse = null;
    let pendingImagePulse = null;

    const downloadUrlCache = new Map(); // storagePath -> {url, exp}

    // ✅ Cache participants for alias lookup + scoring
    let participantsCache = []; // [{uid, alias, aliasLower, ...}]
    let aliasByUid = new Map();

    // ✅ Cache pulses for rich summary + scoring
    let pulsesCache = []; // latest-first

    // ✅ Close-lobby timer
    let closeLobbyTimer = null;

    // ✅ Guess modal state
    let currentGuessPulseId = null;

    // ✅ Selected pulse highlight
    let selectedPulseId = null;

    // ✅ PREP phase state
    let prepActive = false;
    let prepEndsAt = 0;
    let prepTick = null;

    // ✅ Prep image queue (localStorage)
    let prepImages = []; // [{id,name,type,dataUrl}]
    let selectedPrepImage = null; // {id,name,type,dataUrl}

    // ✅ Summary vault state
    let vaultShownForSession = false;
    let vaultAnimating = false;

    // -------------------------
    // Chip file picker wiring
    // -------------------------
    function renderChosenFileName() {
      const f = (pulseImage && pulseImage.files && pulseImage.files[0]) ? pulseImage.files[0] : null;
      if (!chipLabel) return;

      // If a prep image is selected, show that instead
      if (selectedPrepImage) {
        chipLabel.innerHTML = "";
        const name = document.createElement("span");
        name.className = "dv-file-name";
        name.textContent = `Prep: ${selectedPrepImage.name || "image"}`;

        const clear = document.createElement("button");
        clear.className = "dv-file-clear";
        clear.type = "button";
        clear.textContent = "×";
        clear.setAttribute("aria-label", "Clear selected image");
        clear.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          selectedPrepImage = null;
          renderChosenFileName();
        });

        chipLabel.appendChild(name);
        chipLabel.appendChild(clear);
        return;
      }

      if (!f) {
        chipLabel.textContent = "Choose image";
        return;
      }

      chipLabel.innerHTML = "";
      const name = document.createElement("span");
      name.className = "dv-file-name";
      name.textContent = f.name;

      const clear = document.createElement("button");
      clear.className = "dv-file-clear";
      clear.type = "button";
      clear.textContent = "×";
      clear.setAttribute("aria-label", "Clear selected image");
      clear.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        pulseImage.value = "";
        renderChosenFileName();
      });

      chipLabel.appendChild(name);
      chipLabel.appendChild(clear);
    }

    if (btnChooseImage && pulseImage) {
      btnChooseImage.addEventListener("click", () => {
        // Selecting file overrides prep selection
        selectedPrepImage = null;
        pulseImage.click();
      });
      pulseImage.addEventListener("change", () => {
        selectedPrepImage = null;
        renderChosenFileName();
      });
      renderChosenFileName();
    }

    // -------------------------
    // Prep queue storage
    // -------------------------
    function prepLoad() {
      try {
        const raw = localStorage.getItem(PREP_IMAGES_KEY);
        const parsed = raw ? JSON.parse(raw) : [];
        prepImages = Array.isArray(parsed) ? parsed : [];
      } catch {
        prepImages = [];
      }
      renderPrepGrid();
    }

    function prepSave() {
      try { localStorage.setItem(PREP_IMAGES_KEY, JSON.stringify(prepImages)); } catch (_) {}
      renderPrepGrid();
    }

    function prepMarkDone() {
      try { localStorage.setItem(PREP_DONE_KEY, "true"); } catch (_) {}
    }

    function prepIsDone() {
      try { return localStorage.getItem(PREP_DONE_KEY) === "true"; } catch (_) { return false; }
    }

    function prepClearDoneFlag() {
      try { localStorage.removeItem(PREP_DONE_KEY); } catch (_) {}
    }

    async function readFilesAsDataUrls(files) {
      const arr = Array.from(files || []).filter(f => (f.type || "").startsWith("image/"));
      const tasks = arr.map(file => new Promise((resolve) => {
        const r = new FileReader();
        r.onload = () => resolve({ file, dataUrl: String(r.result || "") });
        r.onerror = () => resolve(null);
        r.readAsDataURL(file);
      }));
      const res = (await Promise.all(tasks)).filter(Boolean);
      return res;
    }

    async function prepAddFiles(files) {
      if (!files || !files.length) return;
      const room = DV_PREP_MAX_IMAGES - prepImages.length;
      if (room <= 0) return;

      const data = await readFilesAsDataUrls(files);
      for (const it of data) {
        if (prepImages.length >= DV_PREP_MAX_IMAGES) break;
        const id = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
        prepImages.push({
          id,
          name: it.file.name || "image",
          type: it.file.type || "image/*",
          dataUrl: it.dataUrl
        });
      }
      prepSave();
    }

    function renderPrepGrid() {
      if (dvPrepCount) dvPrepCount.textContent = String(prepImages.length);
      if (!dvPrepGrid) return;

      dvPrepGrid.innerHTML = "";
      if (!prepImages.length) {
        const empty = document.createElement("div");
        empty.style.opacity = "0.75";
        empty.style.fontSize = "13px";
        empty.textContent = "No images queued yet.";
        dvPrepGrid.appendChild(empty);
        return;
      }

      const frag = document.createDocumentFragment();
      for (const img of prepImages) {
        const tile = document.createElement("div");
        tile.className = "dv-prep-tile";

        const im = document.createElement("img");
        im.className = "dv-prep-thumb";
        im.src = img.dataUrl;
        im.alt = img.name || "image";

        const meta = document.createElement("div");
        meta.className = "dv-prep-meta";

        const name = document.createElement("div");
        name.className = "dv-prep-name";
        name.textContent = img.name || "image";

        const remove = document.createElement("button");
        remove.className = "dv-prep-remove";
        remove.type = "button";
        remove.textContent = "Remove";
        remove.addEventListener("click", () => {
          prepImages = prepImages.filter(x => x.id !== img.id);
          // if currently selected, clear selection
          if (selectedPrepImage && selectedPrepImage.id === img.id) {
            selectedPrepImage = null;
            renderChosenFileName();
          }
          prepSave();
        });

        meta.appendChild(name);
        meta.appendChild(remove);

        tile.appendChild(im);
        tile.appendChild(meta);

        frag.appendChild(tile);
      }

      dvPrepGrid.appendChild(frag);
    }

    function prepOverlayShow() {
      dvPrepOverlay?.classList.add("show");
    }
    function prepOverlayHide() {
      dvPrepOverlay?.classList.remove("show");
    }

    function prepStart(endsAtMillis) {
      prepActive = true;
      prepEndsAt = endsAtMillis;

      prepOverlayShow();
      setComposerLocked(true);

      const tick = () => {
        const left = prepEndsAt - Date.now();
        if (dvPrepCountdownEl) dvPrepCountdownEl.textContent = fmtMs(left);

        if (left <= 0) {
          prepStop();
          prepOverlayHide();
          prepMarkDone();
          setComposerLocked(false);
          setStatus("good", "RUNNING", "Preparation finished. You can pulse now.");
        }
      };

      prepStop();
      prepTick = setInterval(tick, 250);
      tick();
    }

    function prepStop() {
      prepActive = false;
      if (prepTick) {
        clearInterval(prepTick);
        prepTick = null;
      }
    }

    // -------------------------
    // “From prep queue” picker
    // -------------------------
    function prepPickerShow() {
      if (!dvPrepPickerBackdrop || !dvPrepPickerGrid) return;
      dvPrepPickerGrid.innerHTML = "";

      if (!prepImages.length) {
        const empty = document.createElement("div");
        empty.style.opacity = "0.8";
        empty.style.fontSize = "13px";
        empty.textContent = "No queued images.";
        dvPrepPickerGrid.appendChild(empty);
      } else {
        for (const img of prepImages) {
          const tile = document.createElement("button");
          tile.type = "button";
          tile.style.border = "1px solid rgba(255,255,255,0.10)";
          tile.style.background = "rgba(255,255,255,0.04)";
          tile.style.borderRadius = "14px";
          tile.style.overflow = "hidden";
          tile.style.padding = "0";
          tile.style.cursor = "pointer";

          const im = document.createElement("img");
          im.src = img.dataUrl;
          im.alt = img.name || "image";
          im.style.width = "100%";
          im.style.aspectRatio = "1/1";
          im.style.objectFit = "cover";
          im.style.display = "block";

          tile.appendChild(im);

          tile.addEventListener("click", () => {
            selectedPrepImage = img;
            // Clear normal file input selection so we don't have ambiguity
            if (pulseImage) pulseImage.value = "";
            renderChosenFileName();
            dvPrepPickerBackdrop.classList.remove("show");
          });

          dvPrepPickerGrid.appendChild(tile);
        }
      }

      dvPrepPickerBackdrop.classList.add("show");
    }

    function prepPickerHide() {
      dvPrepPickerBackdrop?.classList.remove("show");
    }

    dvPrepPickerClose?.addEventListener("click", prepPickerHide);
    dvPrepPickerBackdrop?.addEventListener("click", (e) => {
      if (e.target === dvPrepPickerBackdrop) prepPickerHide();
    });

    btnFromPrep?.addEventListener("click", () => {
      if (state !== "RUNNING") {
        setStatus("warn", "Not running", "Wait for the host to start.");
        return;
      }
      if (prepActive) {
        setStatus("warn", "Preparing", "Finish the preparation timer first.");
        return;
      }
      prepPickerShow();
    });

    // Prep overlay controls
    dvPrepAddMulti?.addEventListener("click", () => dvPrepFileMulti?.click());
    dvPrepAddOne?.addEventListener("click", () => dvPrepFileSingle?.click());

    dvPrepFileMulti?.addEventListener("change", async (e) => {
      const files = Array.from(e.target.files || []);
      e.target.value = "";
      await prepAddFiles(files);
    });
    dvPrepFileSingle?.addEventListener("change", async (e) => {
      const files = Array.from(e.target.files || []);
      e.target.value = "";
      await prepAddFiles(files.slice(0, 1));
    });

    dvPrepClear?.addEventListener("click", () => {
      prepImages = [];
      selectedPrepImage = null;
      renderChosenFileName();
      prepSave();
    });

    dvPrepClose?.addEventListener("click", () => prepOverlayHide());

    // -------------------------
    // Composer lock for PREP
    // -------------------------
    function setComposerLocked(locked) {
      // During prep, we visually keep it off + block actions
      setHidden(composer, !!locked);
      if (locked) {
        composerHelp.textContent = "Preparation phase — queue your images.";
      }
    }

    // -------------------------
    // Setfeed helpers (manual-code fallback)
    // -------------------------
    function normalizeCodeAndroid(raw) { return String(raw || "").trim().toUpperCase().replace(/[\s-]/g, ""); }

    function bytesToB64(bytes) {
      let bin = "";
      const arr = (bytes instanceof Uint8Array) ? bytes : new Uint8Array(bytes);
      for (let i = 0; i < arr.length; i++) bin += String.fromCharCode(arr[i]);
      return btoa(bin);
    }

    async function sha256Hex(str) {
      const data = new TextEncoder().encode(str);
      const hash = await crypto.subtle.digest("SHA-256", data);
      return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, "0")).join("");
    }

    async function deriveAesKeyFromPassphrase(passphrase, saltBytes) {
      const passBytes = new TextEncoder().encode(passphrase);
      const baseKey = await crypto.subtle.importKey("raw", passBytes, { name: "PBKDF2" }, false, ["deriveKey"]);
      return await crypto.subtle.deriveKey(
        { name: "PBKDF2", salt: saltBytes, iterations: 100000, hash: "SHA-256" },
        baseKey,
        { name: "AES-GCM", length: 256 },
        false,
        ["encrypt"]
      );
    }

    async function encryptForCode(rawCode, plaintext) {
      const passphrase = normalizeCodeAndroid(rawCode);
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveAesKeyFromPassphrase(passphrase, salt);

      const ptBytes = new TextEncoder().encode(String(plaintext || ""));
      const ct = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, ptBytes);

      return {
        ciphertextB64: bytesToB64(new Uint8Array(ct)),
        ivB64: bytesToB64(iv),
        saltB64: bytesToB64(salt),
      };
    }

    function tzName() {
      try { return Intl.DateTimeFormat().resolvedOptions().timeZone || "UTC"; } catch (_) { return "UTC"; }
    }

    function getAutosend() {
      try { return localStorage.getItem(SETFEED_AUTOSEND_KEY) === "true"; } catch (_) { return false; }
    }
    function setAutosend(v) {
      try { localStorage.setItem(SETFEED_AUTOSEND_KEY, v ? "true" : "false"); } catch (_) {}
    }

    function getStoredSetfeedCode() {
      try { return (localStorage.getItem(SETFEED_CODE_KEY) || "").trim(); } catch (_) { return ""; }
    }
    function setStoredSetfeedCode(v) {
      try { localStorage.setItem(SETFEED_CODE_KEY, String(v || "").trim()); } catch (_) {}
    }

    function hasSentForThisSession() {
      try { return localStorage.getItem(SENT_FLAG_KEY) === "true"; } catch (_) { return false; }
    }
    function markSentForThisSession() {
      try { localStorage.setItem(SENT_FLAG_KEY, "true"); } catch (_) {}
    }

    function refreshSetfeedUI() {
      const auto = getAutosend();
      btnToggleAutosend.textContent = `Auto-send: ${auto ? "On" : "Off"}`;

      const u = auth.currentUser;
      const canAccountSend = !!u && !isAnon(u) && isGoogleUser(u);

      setHidden(setfeedAccountBox, !canAccountSend);
      setHidden(setfeedCodeBox, canAccountSend);

      const code = (setfeedCodeInput.value || "").trim();
      const hasSummary = !!(session && session.summaryText);
      const canSend =
        (state === "DONE" && hasSummary) &&
        (canAccountSend || !!code);

      btnSendSummary.disabled = !canSend;
      btnSendSummary2.disabled = !canSend;

      if (hasSentForThisSession()) {
        setfeedStatus.textContent = "Summary sent for this session.";
        return;
      }

      if (state !== "DONE") {
        setfeedStatus.textContent = "Summary sends when the session is DONE.";
        return;
      }

      if (!hasSummary) {
        setfeedStatus.textContent = "Waiting for summary generation…";
        return;
      }

      if (canAccountSend) {
        setfeedStatus.textContent =
          auto
            ? "Auto-send is ON: will send once per session (account inbox)."
            : "Ready to send (account inbox).";
      } else {
        setfeedStatus.textContent =
          code
            ? (auto ? "Auto-send is ON: will send once per session." : "Ready to send.")
            : "Paste your Setfeed receive code to send. (Guest sessions can’t target your account inbox.)";
      }
    }

    async function sendSummaryToSetfeed() {
      if (!auth.currentUser) return;

      const u = auth.currentUser;
      const canAccountSend = !!u && !isAnon(u) && isGoogleUser(u);

      if (!session || !session.summaryText) {
        setStatus("warn", "No summary", "Summary not ready yet.");
        return;
      }
      if (hasSentForThisSession()) {
        setStatus("good", "Already sent", "This session’s summary has already been sent.");
        refreshSetfeedUI();
        return;
      }

      btnSendSummary.disabled = true;
      btnSendSummary2.disabled = true;

      try {
        if (canAccountSend) {
          setfeedStatus.textContent = "Sending to account inbox…";
          const call = functions.httpsCallable("delveeSendSummaryToSetfeed");
          await call({ sessionId });

          markSentForThisSession();
          setfeedStatus.textContent = "Sent — check your Setfeed Inbox (web + app).";
          setStatus("good", "Sent", "Summary delivered to your account inbox.");
          return;
        }

        const codeRaw = (setfeedCodeInput.value || "").trim();
        if (!codeRaw) {
          setStatus("warn", "Missing code", "Paste your Setfeed receive code first.");
          return;
        }

        setfeedStatus.textContent = "Encrypting + sending…";

        const normalized = normalizeCodeAndroid(codeRaw);
        const codeHash = await sha256Hex(normalized);

        const enc = await encryptForCode(codeRaw, session.summaryText);

        const deliverAtLocalIso = new Date().toISOString();
        const call = functions.httpsCallable("sendSignedCiphertext");

        await call({
          codeHash,
          ciphertext: enc.ciphertextB64,
          iv: enc.ivB64,
          salt: enc.saltB64,
          deliverAtLocalIso,
          userTimezone: tzName(),
          clientRequestId: randomId("sum"),
          attachments: [],
        });

        markSentForThisSession();
        setfeedStatus.textContent = "Sent — check your Setfeed Inbox.";
        setStatus("good", "Sent", "Summary delivered to your Setfeed Inbox.");
      } catch (e) {
        console.error(e);
        const msg = (e && e.message) ? e.message : "Try again.";
        setfeedStatus.textContent =
          canAccountSend
            ? "Couldn’t send to account inbox. (You may need to deploy delveeSendSummaryToSetfeed.)"
            : "Couldn’t send. Check the code is valid and try again.";
        setStatus("warn", "Send failed", msg);
      } finally {
        refreshSetfeedUI();
      }
    }

    // -------------------------
    // Actions
    // -------------------------
    btnHome.addEventListener("click", () => {
      window.location.href = "./index.html";
    });

    btnCopy.addEventListener("click", async () => {
      try {
        await navigator.clipboard.writeText(sessionId);
        setStatus("good", "Copied", "Session code copied.");
      } catch (_) {
        setStatus("warn", "Copy failed", "Copy manually from the header.");
      }
    });

    btnLeave.addEventListener("click", async () => {
      try {
        const leave = functions.httpsCallable("delveeLeaveSession");
        await leave({ sessionId });
      } catch (_) {}
      window.location.href = "./index.html";
    });

    btnReady.addEventListener("click", async () => {
      if (!auth.currentUser) return;

      const next = !(me && me.ready);
      try {
        btnReady.disabled = true;
        const call = functions.httpsCallable("delveeSetReady");
        await call({ sessionId, ready: next });
      } catch (e) {
        console.error(e);
        setStatus("warn", "Couldn’t update", (e && e.message) ? e.message : "Try again.");
      } finally {
        btnReady.disabled = false;
      }
    });

    btnStart.addEventListener("click", async () => {
      if (!isHost) return;
      try {
        btnStart.disabled = true;
        // Frontend-only PREP: we reset prep done flag on fresh start
        prepClearDoneFlag();
        const call = functions.httpsCallable("delveeStartSession");
        await call({ sessionId, durationMinutes: Number(durationSel.value) });
      } catch (e) {
        console.error(e);
        setStatus("warn", "Couldn’t start", (e && e.message) ? e.message : "Try again.");
      } finally {
        btnStart.disabled = false;
      }
    });

    // ✅ Stop RUNNING early -> COOLDOWN (requires backend callable delveeStopSession)
    btnStop.addEventListener("click", async () => {
      if (!isHost) return;
      if (state !== "RUNNING") return;
      try {
        btnStop.disabled = true;
        const call = functions.httpsCallable("delveeStopSession");
        await call({ sessionId });
      } catch (e) {
        console.error(e);
        setStatus("warn", "Couldn’t stop", (e && e.message) ? e.message : "Deploy delveeStopSession and try again.");
      } finally {
        btnStop.disabled = false;
      }
    });

    btnPulse.addEventListener("click", async () => {
      const text = pulseText.value.trim();
      if (!text) return;

      if (state !== "RUNNING") {
        setStatus("warn", "Not running", "Wait for the host to start.");
        return;
      }
      if (prepActive) {
        setStatus("warn", "Preparing", "Finish the preparation timer first.");
        return;
      }
      if (!prepIsDone() && session && session.state === "RUNNING") {
        setStatus("warn", "Preparing", "Finish the preparation timer first.");
        return;
      }

      try {
        btnPulse.disabled = true;
        composerHelp.textContent = "Sending pulse…";

        if (!pendingTextPulse) pendingTextPulse = randomId("p");
        const call = functions.httpsCallable("delveePulseText");
        await call({ sessionId, clientPulseId: pendingTextPulse, text });

        pendingTextPulse = null;
        pulseText.value = "";
        composerHelp.textContent = "Pulsed.";
      } catch (e) {
        console.error(e);
        composerHelp.textContent = "Couldn’t pulse. Try again.";
        setStatus("warn", "Pulse failed", (e && e.message) ? e.message : "Try again.");
      } finally {
        btnPulse.disabled = false;
      }
    });

    function dataUrlToBytes(dataUrl) {
      const parts = String(dataUrl || "").split(",");
      if (parts.length < 2) throw new Error("Invalid data URL");
      const b64 = parts[1];
      const bin = atob(b64);
      const out = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; i++) out[i] = bin.charCodeAt(i);
      return out;
    }

    btnImage.addEventListener("click", async () => {
      if (state !== "RUNNING") {
        setStatus("warn", "Not running", "Wait for the host to start.");
        return;
      }
      if (prepActive) {
        setStatus("warn", "Preparing", "Finish the preparation timer first.");
        return;
      }
      if (!prepIsDone() && session && session.state === "RUNNING") {
        setStatus("warn", "Preparing", "Finish the preparation timer first.");
        return;
      }

      // Either normal file input OR selected prep image
      const file = (pulseImage.files && pulseImage.files[0]) ? pulseImage.files[0] : null;
      const usePrep = !!selectedPrepImage;

      if (!file && !usePrep) return;

      if (file && !file.type.startsWith("image/")) {
        setStatus("warn", "Not an image", "Choose an image file.");
        return;
      }

      try {
        btnImage.disabled = true;
        composerHelp.textContent = "Uploading image…";

        if (!pendingImagePulse) pendingImagePulse = randomId("img");

        const attachmentId = randomId("a");
        const create = functions.httpsCallable("delveeCreateImageUpload");

        let contentType = "image/png";
        let sizeBytes = 0;
        let bytes;

        if (usePrep) {
          contentType = selectedPrepImage.type || "image/png";
          bytes = dataUrlToBytes(selectedPrepImage.dataUrl);
          sizeBytes = bytes.byteLength;
        } else {
          contentType = file.type;
          bytes = new Uint8Array(await file.arrayBuffer());
          sizeBytes = file.size;
        }

        const res = await create({
          sessionId,
          attachmentId,
          sizeBytes,
          contentType
        });

        const { uploadUrl, storagePath } = res.data || {};
        if (!uploadUrl || !storagePath) throw new Error("Missing uploadUrl/storagePath");

        await fetch(uploadUrl, {
          method: "PUT",
          headers: { "Content-Type": "application/octet-stream" },
          body: bytes
        });

        const commit = functions.httpsCallable("delveePulseImageCommit");
        await commit({
          sessionId,
          clientPulseId: pendingImagePulse,
          attachment: {
            storagePath,
            contentType,
            sizeBytes
          }
        });

        pendingImagePulse = null;

        // If it was from prep queue: remove it from queue so “queued for sending” feels real
        if (usePrep && selectedPrepImage) {
          const usedId = selectedPrepImage.id;
          selectedPrepImage = null;
          prepImages = prepImages.filter(x => x.id !== usedId);
          prepSave();
        }

        pulseImage.value = "";
        renderChosenFileName();
        composerHelp.textContent = "Image pulsed.";
      } catch (e) {
        console.error(e);
        composerHelp.textContent = "Couldn’t pulse image. Try again.";
        setStatus("warn", "Image failed", (e && e.message) ? e.message : "Try again.");
      } finally {
        btnImage.disabled = false;
      }
    });

    btnChat.addEventListener("click", async () => {
      const text = chatText.value.trim();
      if (!text) return;

      if (state !== "COOLDOWN" && state !== "DONE") {
        setStatus("warn", "Chat closed", "Chat opens during cooldown.");
        return;
      }

      try {
        btnChat.disabled = true;
        const call = functions.httpsCallable("delveeChatSend");
        await call({ sessionId, text });
        chatText.value = "";
      } catch (e) {
        console.error(e);
        setStatus("warn", "Chat failed", (e && e.message) ? e.message : "Try again.");
      } finally {
        btnChat.disabled = false;
      }
    });

    // ✅ Enter to send (Pulse + Chat)
    pulseText.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        btnPulse.click();
      }
    });
    chatText.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        btnChat.click();
      }
    });

    // Setfeed controls
    setfeedCodeInput.value = getStoredSetfeedCode();
    setfeedCodeInput.addEventListener("input", () => {
      setStoredSetfeedCode(setfeedCodeInput.value);
      refreshSetfeedUI();
    });

    btnToggleAutosend.addEventListener("click", () => {
      setAutosend(!getAutosend());
      refreshSetfeedUI();
      maybeAutoSend().catch(() => {});
    });

    btnSendSummary.addEventListener("click", sendSummaryToSetfeed);
    btnSendSummary2.addEventListener("click", sendSummaryToSetfeed);

    // Close lobby (requires backend callable)
    btnCloseLobby.addEventListener("click", async () => {
      if (!auth.currentUser) return;
      try {
        btnCloseLobby.disabled = true;
        const call = functions.httpsCallable("delveeCloseLobby");
        await call({ sessionId });
        setStatus("good", "Closed", "Lobby destroyed.");
        setTimeout(() => window.location.href = "./index.html", 600);
      } catch (e) {
        console.error(e);
        setStatus("warn", "Close failed", (e && e.message) ? e.message : "Deploy delveeCloseLobby and try again.");
      } finally {
        btnCloseLobby.disabled = false;
      }
    });

    // -------------------------
    // Guess modal
    // -------------------------
    function modalShowGuess(pulseId, previewText){
      currentGuessPulseId = pulseId;
      selectedPulseId = pulseId;
      guessPreview.textContent = previewText || "—";

      // Update selected highlight in feed
      updateFeedSelectionHighlight();

      const preds = loadPredictions();
      const existing = preds[pulseId] || null;

      guessList.innerHTML = "";
      const frag = document.createDocumentFragment();

      const sorted = [...participantsCache].sort((a,b) => String(a.aliasLower||"").localeCompare(String(b.aliasLower||"")));
      for (const p of sorted) {
        const b = document.createElement("button");
        b.type = "button";
        b.className = "dv-btn";
        b.textContent = p.alias || "—";
        if (existing && existing.guessedUid === p.uid) {
          b.classList.add("dv-btn-primary");
        }
        b.addEventListener("click", () => {
          const next = loadPredictions();
          next[pulseId] = { guessedUid: p.uid, guessedAlias: p.alias || null };
          savePredictions(next);
          modalHideGuess();
          renderSummaryIfReady();
        });
        frag.appendChild(b);
      }

      guessList.appendChild(frag);
      guessBackdrop.classList.add("show");
    }

    function modalHideGuess(){
      guessBackdrop.classList.remove("show");
      currentGuessPulseId = null;
    }

    guessClose.addEventListener("click", modalHideGuess);
    guessBackdrop.addEventListener("click", (e) => {
      if (e.target === guessBackdrop) modalHideGuess();
    });
    guessClear.addEventListener("click", () => {
      if (!selectedPulseId) return;
      const preds = loadPredictions();
      delete preds[selectedPulseId];
      savePredictions(preds);
      modalHideGuess();
      renderSummaryIfReady();
    });

    // -------------------------
    // Realtime rendering
    // -------------------------
    function renderState(nextState) {
      state = nextState || "—";

      // When server says RUNNING, we show PREP locally first (3 minutes)
      const effectiveState = (state === "RUNNING" && !prepIsDone()) ? "PREP" : state;
      statePill.textContent = effectiveState;

      if (effectiveState === "LOBBY") {
        hint.textContent = "Ready up. When everyone is ready, the host begins. Then: 3 minutes preparation.";
      } else if (effectiveState === "PREP") {
        hint.textContent = "Preparation (3 minutes). Queue images now — then the pulse window begins.";
      } else if (effectiveState === "RUNNING") {
        hint.textContent = "Pulse fast. Preview is anonymous. Chat opens during cooldown.";
      } else if (effectiveState === "COOLDOWN") {
        hint.textContent = "Cooldown (3 minutes). Ask who sent what. Summary is preparing.";
      } else if (effectiveState === "DONE") {
        hint.textContent = "Done. Summary is ready.";
      } else if (effectiveState === "CANCELLED") {
        hint.textContent = "This lobby expired before it started.";
      } else {
        hint.textContent = "—";
      }

      // Composer is shown only in RUNNING AND when prep done
      const showComposer = (state === "RUNNING" && prepIsDone());
      setHidden(composer, !showComposer);

      const chatOpen = (state === "COOLDOWN" || state === "DONE");
      chatText.disabled = !chatOpen;
      btnChat.disabled = !chatOpen;
      chatMeta.textContent = chatOpen ? "Open" : "Opens in cooldown";

      // Stop button: host + RUNNING only (server)
      setHidden(btnStop, !(isHost && state === "RUNNING"));

      refreshSetfeedUI();
    }

    function getLocalCooldownEndsAtMillis() {
      // Frontend-only cooldown override (3 minutes).
      // Prefer session.cooldownEndsAtMillis if it exists and is earlier; otherwise clamp to endAt + 3 min.
      if (!session) return null;
      const base = Number(session.endAtMillis || 0);
      if (!base) return session.cooldownEndsAtMillis || null;

      const localEnds = base + DV_COOLDOWN_MS;
      const serverEnds = Number(session.cooldownEndsAtMillis || 0) || null;
      if (!serverEnds) return localEnds;

      // If server ends sooner (unlikely), use it; otherwise show local 3-min target.
      return Math.min(serverEnds, localEnds) || localEnds;
    }

    function renderCountdown() {
      if (!session) { countdownEl.textContent = ""; return; }

      const now = Date.now();

      if (state === "RUNNING" && !prepIsDone()) {
        // Show PREP timer
        const left = Math.max(0, prepEndsAt - now);
        countdownEl.textContent = `PREP · ${fmtMs(left)}`;
        return;
      }

      if (state === "RUNNING" && session.endAtMillis) {
        const left = session.endAtMillis - now;
        countdownEl.textContent = left > 0 ? `RUNNING · ${fmtMs(left)}` : "RUNNING · 00:00";
      } else if (state === "COOLDOWN") {
        const ends = getLocalCooldownEndsAtMillis();
        if (ends) {
          const left = ends - now;
          countdownEl.textContent = left > 0 ? `COOLDOWN · ${fmtMs(left)}` : "COOLDOWN · 00:00";
        } else {
          countdownEl.textContent = "COOLDOWN";
        }
      } else if (state === "LOBBY" && session.reservationExpiresAtMillis) {
        const left = session.reservationExpiresAtMillis - now;
        countdownEl.textContent = left > 0 ? `LOBBY · ${fmtMs(left)}` : "LOBBY · 00:00";
      } else if (state === "DONE") {
        countdownEl.textContent = "DONE";
      } else {
        countdownEl.textContent = state;
      }
    }

    async function getDownloadUrl(storagePath) {
      const cached = downloadUrlCache.get(storagePath);
      const now = Date.now();
      if (cached && cached.exp && now < cached.exp - 20_000) return cached.url;

      const call = functions.httpsCallable("delveeCreateImageDownloadUrl");
      const res = await call({ sessionId, storagePath });
      const url = res.data?.downloadUrl;
      const exp = res.data?.expiresAtMillis;
      if (url) downloadUrlCache.set(storagePath, { url, exp: exp || (now + 240_000) });
      return url || null;
    }

    function rebuildAliasMap(list){
      aliasByUid = new Map();
      for (const p of list) {
        if (p && p.uid) aliasByUid.set(p.uid, p.alias || "—");
      }
    }

    function renderParticipants(list) {
      participantsCache = Array.isArray(list) ? list : [];
      participantsCache.sort((a,b) => String(a.aliasLower||"").localeCompare(String(b.aliasLower||"")));
      rebuildAliasMap(participantsCache);

      const meUid = auth.currentUser?.uid || "";
      const frag = document.createDocumentFragment();

      for (const p of participantsCache) {
        const row = document.createElement("div");
        row.className = "dv-person";

        const left = document.createElement("div");
        left.className = "dv-person-left";

        const name = document.createElement("div");
        name.className = "dv-person-name";
        name.textContent = p.alias || "—";

        const meta = document.createElement("div");
        meta.className = "dv-person-meta";
        const ready = p.ready ? "ready" : "not ready";
        const pulses = typeof p.pulsesCount === "number" ? p.pulsesCount : 0;
        meta.textContent = `${ready} · ${pulses} pulses`;

        left.appendChild(name);
        left.appendChild(meta);

        const badge = document.createElement("div");
        badge.className = "dv-badge";
        badge.textContent = p.ready ? "✓" : "·";

        if (p.uid === meUid) {
          row.classList.add("me");
          badge.classList.add("me");
        }

        row.appendChild(left);
        row.appendChild(badge);
        frag.appendChild(row);
      }

      participantsEl.innerHTML = "";
      participantsEl.appendChild(frag);

      renderSummaryIfReady();
    }

    function summarizePulsePreview(it){
      if (!it) return "—";
      if (it.kind === "image") return "image pulse";
      const t = String(it.text || "").trim();
      return t.length > 140 ? (t.slice(0, 139) + "…") : (t || "[empty]");
    }

    function updateFeedSelectionHighlight() {
      const nodes = feed.querySelectorAll("[data-pulse-id]");
      nodes.forEach(n => {
        const pid = n.getAttribute("data-pulse-id");
        n.classList.toggle("selected", !!selectedPulseId && pid === selectedPulseId);
      });
    }

    async function renderFeed(items) {
      pulsesCache = Array.isArray(items) ? items : [];
      feedMeta.textContent = `${pulsesCache.length} pulses`;

      const frag = document.createDocumentFragment();

      for (const it of pulsesCache) {
        const card = document.createElement("div");
        card.className = "dv-pulse";
        card.tabIndex = 0;
        card.setAttribute("role", "button");
        card.setAttribute("aria-label", "Guess sender");

        const kind = document.createElement("div");
        kind.className = "dv-pulse-kind";
        kind.textContent = it.kind === "image" ? "image" : "text";
        card.appendChild(kind);

        if (it.kind === "text") {
          const body = document.createElement("div");
          body.className = "dv-pulse-text";
          body.textContent = it.text || "";
          card.appendChild(body);
        } else if (it.kind === "image" && it.attachment && it.attachment.storagePath) {
          const imgWrap = document.createElement("div");
          imgWrap.className = "dv-pulse-imgwrap";

          const img = document.createElement("img");
          img.className = "dv-pulse-img";
          img.alt = "Pulse image";

          imgWrap.appendChild(img);
          card.appendChild(imgWrap);

          getDownloadUrl(it.attachment.storagePath)
            .then((url) => { if (url) img.src = url; })
            .catch(() => {});
        }

        const pulseId = it.clientPulseId ? `${it.senderUid || "?"}_${it.clientPulseId}` : (it.id || it.createdAtMillis || randomId("pulse"));
        card.setAttribute("data-pulse-id", pulseId);

        card.addEventListener("click", () => modalShowGuess(pulseId, summarizePulsePreview(it)));
        card.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            modalShowGuess(pulseId, summarizePulsePreview(it));
          }
        });

        frag.appendChild(card);
      }

      feed.innerHTML = "";
      feed.appendChild(frag);

      updateFeedSelectionHighlight();
    }

    function renderChat(items) {
      const list = Array.isArray(items) ? items : [];
      const frag = document.createDocumentFragment();

      for (const m of list) {
        const row = document.createElement("div");
        row.className = "dv-chat-msg";

        const alias = aliasByUid.get(m.senderUid) || "—";

        const a = document.createElement("div");
        a.className = "dv-chat-alias";
        a.textContent = alias;

        const b = document.createElement("div");
        b.className = "dv-chat-body";
        b.textContent = m.text || "";

        row.appendChild(a);
        row.appendChild(b);

        frag.appendChild(row);
      }

      chat.innerHTML = "";
      chat.appendChild(frag);
    }

    function computePredictionScore(){
      const preds = loadPredictions();
      const entries = Object.entries(preds || {});
      if (!entries.length) return { guessed: 0, correct: 0 };

      const map = new Map();
      for (const it of pulsesCache) {
        const pid = it.clientPulseId ? `${it.senderUid || "?"}_${it.clientPulseId}` : null;
        if (pid) map.set(pid, it.senderUid || null);
      }

      let guessed = 0;
      let correct = 0;

      for (const [pulseId, guess] of entries) {
        if (!guess || !guess.guessedUid) continue;
        guessed++;
        const actual = map.get(pulseId);
        if (actual && actual === guess.guessedUid) correct++;
      }

      return { guessed, correct };
    }

    function buildSummaryByAlias(){
      const groups = new Map();
      for (const it of (pulsesCache || [])) {
        const uid = it.senderUid || "unknown";
        const alias = aliasByUid.get(uid) || "—";
        const key = `${alias} (${String(uid).slice(0,6)}…)`;

        if (!groups.has(key)) groups.set(key, []);
        if (it.kind === "image") groups.get(key).push("• [image]");
        else groups.get(key).push(`• ${String(it.text || "").trim() || "[empty]"}`);
      }

      const keys = Array.from(groups.keys()).sort((a,b) => a.localeCompare(b));
      const out = [];
      for (const k of keys) {
        out.push(k);
        out.push(...groups.get(k));
        out.push("");
      }
      return out.length ? out.join("\n").trim() : "(no pulses)";
    }

    function scheduleCloseLobbyButton(){
      try { if (closeLobbyTimer) clearTimeout(closeLobbyTimer); } catch (_) {}
      closeLobbyTimer = null;

      setHidden(btnCloseLobby, true);
      setHidden(closeLobbyHint, true);

      if (!session) return;
      if (state !== "DONE") return;

      const genStr = session.summaryReadyAtUtc || (session.summaryStats && session.summaryStats.generatedAtUtc) || null;
      if (!genStr) return;

      const genMs = Date.parse(genStr);
      if (!Number.isFinite(genMs)) return;

      const showAt = genMs + 2 * 60_000;
      const now = Date.now();
      const delay = Math.max(0, showAt - now);

      closeLobbyTimer = setTimeout(() => {
        setHidden(btnCloseLobby, !isHost);
        setHidden(closeLobbyHint, !isHost);
      }, delay);
    }

    // -------------------------
    // ✅ Summary vault reveal
    // -------------------------
    function vaultShow() {
      dvSummaryVault?.classList.add("show");
    }
    function vaultHide() {
      dvSummaryVault?.classList.remove("show");
    }

    dvVaultClose?.addEventListener("click", vaultHide);
    dvSummaryVault?.addEventListener("click", (e) => {
      if (e.target === dvSummaryVault) vaultHide();
    });

    async function vaultRunRevealThenShowContent() {
      if (vaultAnimating) return;
      vaultAnimating = true;

      vaultShow();
      dvVaultContent.classList.remove("show");
      dvVaultStage.style.display = "flex";

      const steps = ["ready.", "set.", "reveal."];
      for (let i = 0; i < steps.length; i++) {
        dvVaultWord.textContent = steps[i];
        // small “pop” retrigger
        dvVaultWord.style.animation = "none";
        // eslint-disable-next-line no-unused-expressions
        dvVaultWord.offsetHeight;
        dvVaultWord.style.animation = "";
        await new Promise(r => setTimeout(r, 700));
      }

      // Brief beat then show content
      await new Promise(r => setTimeout(r, 350));

      dvVaultStage.style.display = "none";
      dvVaultContent.classList.add("show");

      vaultAnimating = false;
    }

    function renderSummaryIfReady() {
      const has = !!(session && session.summaryText);

      if (state === "DONE" && has) {
        summaryTextEl.textContent = session.summaryText || "";

        const gen = (session.summaryStats && session.summaryStats.generatedAtUtc)
          ? session.summaryStats.generatedAtUtc
          : (session.summaryReadyAtUtc || "—");
        summaryMeta.textContent = `Generated: ${gen}`;

        const score = computePredictionScore();
        summaryScore.textContent =
          score.guessed > 0
            ? `Correct predictions: ${score.correct} / ${score.guessed}`
            : "Correct predictions: — (click pulses to make guesses)";

        summaryByAliasEl.textContent = buildSummaryByAlias();

        // Enable collage button if there are any images
        const imgCount = (pulsesCache || []).filter(p => p.kind === "image" && p.attachment && p.attachment.storagePath).length;
        btnDownloadCollage.disabled = imgCount === 0;
        collageStatus.textContent = imgCount
          ? `Collage will include summary text + ${imgCount} image${imgCount === 1 ? "" : "s"}.`
          : "No images in this session to collage.";

        // Show vault once per DONE summary availability
        if (!vaultShownForSession) {
          vaultShownForSession = true;
          vaultRunRevealThenShowContent().catch(() => {});
        }
      }

      scheduleCloseLobbyButton();
      refreshSetfeedUI();
    }

    // -------------------------
    // ✅ Collage download (client-side)
    // -------------------------
    function loadImage(url) {
      return new Promise((resolve) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => resolve(img);
        img.onerror = () => resolve(null);
        img.src = url;
      });
    }

    async function buildCollagePngBlob() {
      const summary = String(session?.summaryText || "").trim();
      const imagePulses = (pulsesCache || [])
        .filter(p => p.kind === "image" && p.attachment && p.attachment.storagePath)
        .slice()
        .reverse(); // oldest-first looks nicer for collage

      const urls = [];
      for (const p of imagePulses) {
        try {
          const u = await getDownloadUrl(p.attachment.storagePath);
          if (u) urls.push(u);
        } catch (_) {}
      }

      const imgs = (await Promise.all(urls.map(loadImage))).filter(Boolean);

      // Layout config
      const padding = 36;
      const headerH = 160;
      const footerH = 28;
      const cols = 4;
      const tile = 260;
      const gap = 14;

      const rows = Math.max(1, Math.ceil(imgs.length / cols));
      const gridW = cols * tile + (cols - 1) * gap;
      const gridH = rows * tile + (rows - 1) * gap;

      const width = Math.max(900, padding * 2 + gridW);
      const height = padding * 2 + headerH + gridH + footerH;

      const canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;

      const ctx = canvas.getContext("2d");
      if (!ctx) throw new Error("Canvas unavailable");

      // Background
      ctx.fillStyle = "#0F1114";
      ctx.fillRect(0, 0, width, height);

      // Soft header glow
      ctx.globalAlpha = 0.18;
      ctx.fillStyle = "#8ca0ff";
      ctx.beginPath();
      ctx.ellipse(width * 0.32, 70, 320, 130, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;

      // Title
      ctx.fillStyle = "rgba(233,238,246,0.96)";
      ctx.font = "800 34px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("Delvee summary", padding, padding + 44);

      // Small meta line
      const gen = (session?.summaryStats?.generatedAtUtc) || session?.summaryReadyAtUtc || new Date().toISOString();
      ctx.fillStyle = "rgba(233,238,246,0.70)";
      ctx.font = "500 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText(`Session ${sessionId} · Generated: ${gen}`, padding, padding + 72);

      // Summary text block (wrapped)
      const maxTextW = width - padding * 2;
      const textTop = padding + 92;
      ctx.fillStyle = "rgba(233,238,246,0.88)";
      ctx.font = "500 14px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace";

      function wrapLines(text, maxW) {
        const words = text.split(/\s+/).filter(Boolean);
        const lines = [];
        let line = "";
        for (const w of words) {
          const next = line ? (line + " " + w) : w;
          if (ctx.measureText(next).width <= maxW) {
            line = next;
          } else {
            if (line) lines.push(line);
            line = w;
          }
        }
        if (line) lines.push(line);
        return lines;
      }

      const clipped = summary.length > 520 ? (summary.slice(0, 520) + "…") : summary;
      const lines = wrapLines(clipped || "(no summary text)", maxTextW);
      const maxLines = 4;
      const used = lines.slice(0, maxLines);

      let y = textTop;
      for (const ln of used) {
        ctx.fillText(ln, padding, y);
        y += 18;
      }

      // Grid start
      const gridLeft = padding;
      const gridTop = padding + headerH;

      // Draw tiles
      let idx = 0;
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const x = gridLeft + c * (tile + gap);
          const yy = gridTop + r * (tile + gap);

          // Tile background
          ctx.fillStyle = "rgba(255,255,255,0.06)";
          roundRect(ctx, x, yy, tile, tile, 18);
          ctx.fill();

          const im = imgs[idx++];
          if (!im) continue;

          // Fit cover
          const { sx, sy, sw, sh } = coverSourceRect(im.width, im.height, tile, tile);

          // Clip rounded
          ctx.save();
          roundRect(ctx, x, yy, tile, tile, 18);
          ctx.clip();
          ctx.drawImage(im, sx, sy, sw, sh, x, yy, tile, tile);
          ctx.restore();

          // Border
          ctx.strokeStyle = "rgba(255,255,255,0.12)";
          ctx.lineWidth = 1;
          roundRect(ctx, x + 0.5, yy + 0.5, tile - 1, tile - 1, 18);
          ctx.stroke();
        }
      }

      // Footer
      ctx.fillStyle = "rgba(233,238,246,0.55)";
      ctx.font = "500 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("Created in Delvee · Client-side collage prototype", padding, height - padding + 10);

      return await new Promise((resolve) => canvas.toBlob(resolve, "image/png", 0.92));
    }

    function roundRect(ctx, x, y, w, h, r) {
      const rr = Math.min(r, w / 2, h / 2);
      ctx.beginPath();
      ctx.moveTo(x + rr, y);
      ctx.arcTo(x + w, y, x + w, y + h, rr);
      ctx.arcTo(x + w, y + h, x, y + h, rr);
      ctx.arcTo(x, y + h, x, y, rr);
      ctx.arcTo(x, y, x + w, y, rr);
      ctx.closePath();
    }

    function coverSourceRect(srcW, srcH, dstW, dstH) {
      const srcAR = srcW / srcH;
      const dstAR = dstW / dstH;
      let sw = srcW, sh = srcH, sx = 0, sy = 0;

      if (srcAR > dstAR) {
        // source wider -> crop width
        sh = srcH;
        sw = Math.floor(srcH * dstAR);
        sx = Math.floor((srcW - sw) / 2);
        sy = 0;
      } else {
        // source taller -> crop height
        sw = srcW;
        sh = Math.floor(srcW / dstAR);
        sx = 0;
        sy = Math.floor((srcH - sh) / 2);
      }
      return { sx, sy, sw, sh };
    }

    btnDownloadCollage?.addEventListener("click", async () => {
      if (!session || !session.summaryText) return;
      try {
        btnDownloadCollage.disabled = true;
        collageStatus.textContent = "Generating collage…";

        const blob = await buildCollagePngBlob();
        if (!blob) throw new Error("Could not generate PNG");

        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `delvee_summary_${sessionId}.png`;
        document.body.appendChild(a);
        a.click();
        a.remove();

        setTimeout(() => URL.revokeObjectURL(url), 10_000);
        collageStatus.textContent = "Collage downloaded.";
      } catch (e) {
        console.error(e);
        collageStatus.textContent = "Couldn’t generate collage (some images may block canvas).";
        setStatus("warn", "Collage failed", (e && e.message) ? e.message : "Try again.");
      } finally {
        // re-enable if there are images
        const imgCount = (pulsesCache || []).filter(p => p.kind === "image" && p.attachment && p.attachment.storagePath).length;
        btnDownloadCollage.disabled = imgCount === 0;
      }
    });

    // -------------------------
    // Auto-send
    // -------------------------
    async function maybeAutoSend() {
      if (!getAutosend()) return;
      if (hasSentForThisSession()) return;

      const u = auth.currentUser;
      const canAccountSend = !!u && !isAnon(u) && isGoogleUser(u);
      const code = (setfeedCodeInput.value || "").trim();

      if (!(state === "DONE" && session && session.summaryText)) return;
      if (!canAccountSend && !code) return;

      await sendSummaryToSetfeed();
    }

    // -------------------------
    // ✅ Guest join: ensure some auth (anonymous) + ensure alias
    // -------------------------
    async function ensureAuthAndAlias() {
      let a = getAlias();
      if (!a) {
        a = (window.prompt("Choose an alias for this lobby (short, no emojis):") || "").trim();
        if (!a) throw new Error("Alias required to join.");
        setAlias(a);
      }

      if (auth.currentUser) return;

      setStatus("good", "Joining as guest…", "No sign-in required for join links.");
      try {
        await auth.signInAnonymously();
      } catch (e) {
        throw new Error("Guest join is unavailable. Enable Anonymous Auth in Firebase or sign in on the home page.");
      }
    }

    // -------------------------
    // PREP trigger logic
    // -------------------------
    function maybeStartPrepPhase() {
      // Start prep when server enters RUNNING and we haven't done prep yet
      if (!session) return;
      if (session.state !== "RUNNING") return;

      if (prepIsDone()) return;
      if (prepActive) return;

      // Determine prep start moment: use session.startAtMillis if present, otherwise now.
      const startAt = Number(session.startAtMillis || 0) || Date.now();
      const endsAt = startAt + DV_PREP_MS;

      // If we're already past the prep window (late join), mark done.
      if (Date.now() >= endsAt) {
        prepMarkDone();
        setComposerLocked(false);
        return;
      }

      // Ensure prep queue loaded
      prepLoad();

      // Show overlay and begin countdown
      setStatus("good", "PREP", "Prepare your images.");
      prepStart(endsAt);
    }

    // -------------------------
    // Boot: join + subscribe
    // -------------------------
    let booted = false;
    async function boot() {
      if (booted) return;
      booted = true;

      if (!sessionId) return;

      // initialize prep UI
      document.getElementById("dvPrepMaxA").textContent = String(DV_PREP_MAX_IMAGES);
      document.getElementById("dvPrepMaxB").textContent = String(DV_PREP_MAX_IMAGES);
      prepLoad();

      try {
        setStatus("good", "Connecting…", "Preparing your lobby session…");
        await ensureAuthAndAlias();
      } catch (e) {
        console.error(e);
        setStatus("warn", "Can’t join", e && e.message ? e.message : "Return to home.");
        setTimeout(() => window.location.href = "./index.html", 1100);
        return;
      }

      const myAlias = getAlias();

      try {
        const join = functions.httpsCallable("delveeJoinSession");
        await join({ sessionId, alias: myAlias });
      } catch (e) {
        console.error(e);
        setStatus("warn", "Couldn’t join", (e && e.message) ? e.message : "Try again.");
        return;
      }

      setStatus("good", "Connected", "Realtime lobby active.");
      refreshSetfeedUI();

      unsub.push(
        sref.onSnapshot((snap) => {
          const d = snap.data() || {};
          session = d;

          const st = d.state || "—";

          isHost = (d.hostUid && auth.currentUser && d.hostUid === auth.currentUser.uid);
          setHidden(hostControls, !isHost);

          // If session resets back to LOBBY, clear vault shown + prep done (so next run works)
          if (st === "LOBBY") {
            vaultShownForSession = false;
            vaultAnimating = false;
            prepStop();
            prepOverlayHide();
            // Keep prep images (user may want them), but clear prep done state so prep happens next start
            prepClearDoneFlag();
          }

          renderState(st);

          // Start PREP when RUNNING begins (frontend-only)
          maybeStartPrepPhase();

          renderCountdown();
          renderSummaryIfReady();

          maybeAutoSend().catch(() => {});
        }, (err) => {
          console.error(err);
          setStatus("warn", "Realtime blocked", "Check Firestore rules for Delvee participant reads.");
        })
      );

      unsub.push(
        pref.doc(auth.currentUser.uid).onSnapshot((snap) => {
          me = snap.data() || null;
          const ready = !!(me && me.ready);
          btnReady.textContent = ready ? "Unready" : "Ready";
        })
      );

      unsub.push(
        pref.onSnapshot((snap) => {
          const list = snap.docs.map(d => d.data());
          renderParticipants(list);
        })
      );

      unsub.push(
        pulsesRef.orderBy("createdAtMillis", "desc").limit(250).onSnapshot((snap) => {
          const list = snap.docs.map(d => d.data());
          renderFeed(list);
          renderSummaryIfReady();
        })
      );

      unsub.push(
        chatRef.orderBy("createdAtMillis", "desc").limit(200).onSnapshot((snap) => {
          const list = snap.docs.map(d => d.data());
          renderChat(list);
        })
      );

      setInterval(() => {
        // Keep countdown updated and keep prep overlay timer live
        renderCountdown();

        // If prep is active and server leaves RUNNING, stop prep
        if (prepActive && session && session.state !== "RUNNING") {
          prepStop();
          prepOverlayHide();
        }
      }, 350);
    }

    auth.onAuthStateChanged(() => boot());

    window.addEventListener("beforeunload", () => {
      for (const u of unsub) try { u(); } catch (_) {}
      unsub = [];
    });

    // Also allow clicking outside prep overlay inner to keep it open (no close), but ESC closes overlays
    window.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        if (guessBackdrop.classList.contains("show")) guessBackdrop.classList.remove("show");
        if (dvPrepPickerBackdrop.classList.contains("show")) dvPrepPickerBackdrop.classList.remove("show");
        if (dvSummaryVault.classList.contains("show")) vaultHide();
        if (dvPrepOverlay.classList.contains("show")) prepOverlayHide();
      }
    });
  </script>
</body>
</html>
